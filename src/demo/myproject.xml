<haxe>
	<class path="flash.ui.Mouse" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/Mouse.hx" extern="1">
		<cursor public="1" static="1"><e path="flash.ui.MouseCursor"/></cursor>
		<supportsCursor public="1" static="1"><e path="Bool"/></supportsCursor>
		<hide public="1" set="method" static="1"><f a=""><e path="Void"/></f></hide>
		<registerCursor public="1" static="1"><f a="cursor">
	<c path="flash.display.MouseCursorData"/>
	<e path="Void"/>
</f></registerCursor>
		<show public="1" set="method" static="1"><f a=""><e path="Void"/></f></show>
	</class>
	<enum path="flash.display.ColorCorrection" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
	</enum>
	<enum path="flash.text.TextFormatAlign" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFormatAlign.hx">
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<CENTER/>
	</enum>
	<enum path="flash.display.StageAlign" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
	</enum>
	<class path="haxel.HxlMonitor" params="" file="../haxel/HxlMonitor.hx">
		<_size>
			<c path="Int"/>
			<haxe_doc>
	 * Stores the requested size of the monitor array.
	 </haxe_doc>
		</_size>
		<_itr>
			<c path="Int"/>
			<haxe_doc>
	 * Keeps track of where we are in the array.
	 </haxe_doc>
		</_itr>
		<_data>
			<c path="Array"><c path="Float"/></c>
			<haxe_doc>
	 * An array to hold all the data we are averaging.
	 </haxe_doc>
		</_data>
		<add public="1" set="method" line="46">
			<f a="Data">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adds an entry to the array of data.
	 * 
	 * @param	Data	The value you want to track and average.
	 </haxe_doc>
		</add>
		<average public="1" set="method" line="58">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Averages the value of all the numbers in the monitor window.
	 * 
	 * @return	The average value of all the numbers in the monitor window.
	 </haxe_doc>
		</average>
		<new public="1" set="method" line="30">
			<f a="Size:?Default">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates the monitor array and sets the size.
	 * 
	 * @param	Size	The desired size - more entries means a longer window of averaging.
	 * @param	Default	The default value of the entries in the array (0 by default).
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A simple class for aggregating and averaging data.
 </haxe_doc>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="C:\Motion-Twin\haxe/std/flash9/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\Motion-Twin\haxe/std/flash9/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="C:\Motion-Twin\haxe/std/flash9/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1"><f a=""><e path="Void"/></f></_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<fps public="1" set="null"><c path="Float"/></fps>
		<height public="1" set="null"><c path="Int"/></height>
		<index public="1" set="null"><c path="Int"/></index>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<quality public="1" set="null"><c path="Int"/></quality>
		<width public="1" set="null"><c path="Int"/></width>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.TriangleCulling" params="" file="C:\Motion-Twin\haxe/std/flash9/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
	</enum>
	<class path="flash.text.TextFormat" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\Motion-Twin\haxe/std/flash9/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
	</enum>
	<class path="haxel.HxlPoint" params="" file="../haxel/HxlPoint.hx">
		<x public="1">
			<c path="Float"/>
			<haxe_doc>
	 * @default 0
	 </haxe_doc>
		</x>
		<y public="1">
			<c path="Float"/>
			<haxe_doc>
	 * @default 0
	 </haxe_doc>
		</y>
		<clone public="1" set="method" line="25"><f a=""><c path="haxel.HxlPoint"/></f></clone>
		<toString public="1" set="method" line="28"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="20">
			<f a="?X:?Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Instantiate a new point object.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 </haxe_doc>
		</new>
	</class>
	<class path="haxel.HxlRect" params="" file="../haxel/HxlRect.hx">
		<extends path="haxel.HxlPoint"/>
		<bottom public="1" get="getBottom" set="null"><c path="Float"/></bottom>
		<left public="1" get="getLeft" set="null"><c path="Float"/></left>
		<right public="1" get="getRight" set="null"><c path="Float"/></right>
		<top public="1" get="getTop" set="null"><c path="Float"/></top>
		<width public="1">
			<c path="Float"/>
			<haxe_doc>
	 * @default 0
	 </haxe_doc>
		</width>
		<height public="1">
			<c path="Float"/>
			<haxe_doc>
	 * @default 0
	 </haxe_doc>
		</height>
		<getLeft public="1" set="method" line="38">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * The X coordinate of the left side of the rectangle.  Read-only.
	 </haxe_doc>
		</getLeft>
		<getRight public="1" set="method" line="45">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * The X coordinate of the right side of the rectangle.  Read-only.
	 </haxe_doc>
		</getRight>
		<getTop public="1" set="method" line="52">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * The Y coordinate of the top of the rectangle.  Read-only.
	 </haxe_doc>
		</getTop>
		<getBottom public="1" set="method" line="59">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * The Y coordinate of the bottom of the rectangle.  Read-only.
	 </haxe_doc>
		</getBottom>
		<new public="1" set="method" line="29">
			<f a="?X:?Y:?Width:?Height">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * Stores a rectangle.
 </haxe_doc>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<enum path="flash.text.TextFormatDisplay" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
	</enum>
	<class path="flash.events.Event" params="" file="C:\Motion-Twin\haxe/std/flash9/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1"><c path="String"/></CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<COPY public="1" static="1"><c path="String"/></COPY>
		<CUT public="1" static="1"><c path="String"/></CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1"><c path="String"/></EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1"><c path="String"/></FRAME_CONSTRUCTED>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1"><c path="String"/></PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1"><c path="String"/></SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><e path="Bool"/></altKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="haxel.HxlObject" params="" file="../haxel/HxlObject.hx">
		<extends path="haxel.HxlRect"/>
		<_pZero line="118" static="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * A handy "empty point" object
	 </haxe_doc>
		</_pZero>
		<_refreshBounds public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Flag for whether the bounding box visuals need to be refreshed.
	 </haxe_doc>
		</_refreshBounds>
		<solid public="1" get="getSolid" set="setSolid"><e path="Bool"/></solid>
		<scrollFactor public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * A point that can store numbers from 0 to 1 (for X and Y independently)
	 * that governs how much this object is affected by the camera subsystem.
	 * 0 means it never moves, like a HUD element or far background graphic.
	 * 1 means it scrolls along a the same speed as the foreground layer.
	 * scrollFactor is initialized as (1,1) by default.
	 </haxe_doc>
		</scrollFactor>
		<origin public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * WARNING: The origin of the sprite will default to its center.
	 * If you change this, the visuals and the collisions will likely be
	 * pretty out-of-sync if you do any rotation.
	 </haxe_doc>
		</origin>
		<_group public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Dedicated internal flag for whether or not this class is a FlxGroup.
	 </haxe_doc>
		</_group>
		<visible public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * If an object is not visible, the game loop will not automatically call <code>render()</code> on it.
	 ]]></haxe_doc>
		</visible>
		<alwaysVisible public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If true, object is not affected by autoVisible.
	 </haxe_doc>
		</alwaysVisible>
		<active public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * If an object is not alive, the game loop will not automatically call <code>update()</code> on it.
	 ]]></haxe_doc>
		</active>
		<exists public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Kind of a global on/off switch for any objects descended from <code>FlxObject</code>.
	 ]]></haxe_doc>
		</exists>
		<_solid>
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Internal tracker for whether or not the object collides (see <code>solid</code>).
	 ]]></haxe_doc>
		</_solid>
		<dead public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Handy for tracking gameplay or animations.
	 </haxe_doc>
		</dead>
		<velocity public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * The basic speed of this object.
	 </haxe_doc>
		</velocity>
		<acceleration public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * How fast the speed of this object is changing.
	 * Useful for smooth movement and gravity.
	 </haxe_doc>
		</acceleration>
		<drag public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * This isn't drag exactly, more like deceleration that is only applied
	 * when acceleration is not affecting the sprite.
	 </haxe_doc>
		</drag>
		<maxVelocity public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc><![CDATA[
	 * If you are using <code>acceleration</code>, you can use <code>maxVelocity</code> with it
	 * to cap the speed automatically (very useful!).
	 ]]></haxe_doc>
		</maxVelocity>
		<angle public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Set the angle of a sprite to rotate it.
	 * WARNING: rotating sprites decreases rendering
	 * performance for this sprite by a factor of 10x!
	 </haxe_doc>
		</angle>
		<angularVelocity public="1">
			<c path="Float"/>
			<haxe_doc>
	 * This is how fast you want this sprite to spin.
	 </haxe_doc>
		</angularVelocity>
		<angularAcceleration public="1">
			<c path="Float"/>
			<haxe_doc>
	 * How fast the spin speed should change.
	 </haxe_doc>
		</angularAcceleration>
		<angularDrag public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[
	 * Like <code>drag</code> but for spinning.
	 ]]></haxe_doc>
		</angularDrag>
		<maxAngular public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[
	 * Use in conjunction with <code>angularAcceleration</code> for fluid spin speed control.
	 ]]></haxe_doc>
		</maxAngular>
		<thrust public="1">
			<c path="Float"/>
			<haxe_doc>
	 * If you want to do Asteroids style stuff, check out thrust,
	 * instead of directly accessing the object's velocity or acceleration.
	 </haxe_doc>
		</thrust>
		<maxThrust public="1">
			<c path="Float"/>
			<haxe_doc><![CDATA[
	 * Used to cap <code>thrust</code>, helpful and easy!
	 ]]></haxe_doc>
		</maxThrust>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * This is a pre-allocated Flash Point object, which is useful for certain Flash graphics API calls
	 </haxe_doc>
		</_flashPoint>
		<zIndex public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The z-index of this object. Objects are rendered in order of z-index, lowest to highest.
	 </haxe_doc>
		</zIndex>
		<_point><c path="haxel.HxlPoint"/></_point>
		<moves public="1">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Set this to false if you want to skip the automatic motion/movement stuff (see <code>updateMotion()</code>).
	 * FlxObject and FlxSprite default to true.
	 * FlxText, FlxTileblock, FlxTilemap and FlxSound default to false.
	 ]]></haxe_doc>
		</moves>
		<getScreenXY public="1" set="method" line="182">
			<f a="?Point">
				<c path="haxel.HxlPoint"/>
				<c path="haxel.HxlPoint"/>
			</f>
			<haxe_doc><![CDATA[
	 * Call this function to figure out the on-screen position of the object.
	 * 
	 * @param	P	Takes a <code>Point</code> object and assigns the post-scrolled X and Y values of this object to it.
	 * 
	 * @return	The <code>Point</code> you passed in, or a new <code>Point</code> if you didn't pass one, containing the screen X and Y position of this object.
	 ]]></haxe_doc>
		</getScreenXY>
		<onScreen public="1" set="method" line="194">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Check and see if this object is currently on screen.
	 * 
	 * @return	Whether the object is on screen or not.
	 </haxe_doc>
		</onScreen>
		<kill public="1" set="method" line="207">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Call this function to "kill" a sprite so that it no longer 'exists'.
	 </haxe_doc>
		</kill>
		<reset public="1" set="method" line="219">
			<f a="X:Y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Handy function for reviving game objects.
	 * Resets their existence flags and position, including LAST position.
	 * 
	 * @param	X	The new X position of this object.
	 * @param	Y	The new Y position of this object.
	 </haxe_doc>
		</reset>
		<destroy public="1" set="method" line="229">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Called by <code>FlxGroup</code>, commonly when game states are changed.
	 ]]></haxe_doc>
		</destroy>
		<getSolid public="1" set="method" line="236">
			<f a=""><e path="Bool"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>solid</code> to true if you want to collide this object.
	 ]]></haxe_doc>
		</getSolid>
		<setSolid public="1" set="method" line="243">
			<f a="Solid">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setSolid>
		<updateMotion set="method" line="252">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function for updating the position and speed of this object.
	 * Useful for cases when you need to update this but are buried down in too many supers.
	 </haxe_doc>
		</updateMotion>
		<update public="1" set="method" line="316">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the main game loop, handles motion/physics and game logic
	 </haxe_doc>
		</update>
		<render public="1" set="method" line="324">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Override this function to draw graphics (see <code>HxlSprite</code>).
	 ]]></haxe_doc>
		</render>
		<getBoundingColor public="1" set="method" line="331">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Returns the appropriate color for the bounding box depending on object state.
	 </haxe_doc>
		</getBoundingColor>
		<overlapsPoint public="1" set="method" line="350">
			<f a="X:Y:?PerPixel">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Checks to see if a point in 2D space overlaps this <code>HxlObject</code> object.
	 * 
	 * @param	X			The X coordinate of the point.
	 * @param	Y			The Y coordinate of the point.
	 * @param	PerPixel	Whether or not to use per pixel collision checking (only available in <code>HxlSprite</code> subclass).
	 * 
	 * @return	Whether or not the point overlaps this object.
	 ]]></haxe_doc>
		</overlapsPoint>
		<new public="1" set="method" line="144"><f a="?X:?Y:?Width:?Height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * Base class for which most display objects.
 </haxe_doc>
	</class>
	<class path="haxel.HxlGroup" params="" file="../haxel/HxlGroup.hx">
		<extends path="haxel.HxlObject"/>
		<zIndexSort public="1" set="method" line="449" static="1">
			<f a="obj1:obj2">
				<c path="haxel.HxlObject"/>
				<c path="haxel.HxlObject"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Sorting function for zIndex.
	 </haxe_doc>
		</zIndexSort>
		<members public="1"><c path="Array"><d/></c></members>
		<_last><c path="haxel.HxlPoint"/></_last>
		<_first><e path="Bool"/></_first>
		<add public="1" set="method" line="26">
			<f a="Object:?ShareScroll">
				<c path="haxel.HxlObject"/>
				<e path="Bool"/>
				<c path="haxel.HxlObject"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a new <code>HxlObject</code> subclass (HxlSprite, HxlBlock, etc) to the list of children
	 *
	 * @param	Object			The object you want to add
	 * @param	ShareScroll		Whether or not this HxlCore should sync up with this layer's scrollFactor
	 *
	 * @return	The same <code>HxlCore</code> object that was passed in.
	 ]]></haxe_doc>
		</add>
		<replace public="1" set="method" line="43">
			<f a="OldObject:NewObject">
				<c path="haxel.HxlObject"/>
				<c path="haxel.HxlObject"/>
				<c path="haxel.HxlObject"/>
			</f>
			<haxe_doc><![CDATA[
	 * Replaces an existing <code>HxlObject</code> with a new one.
	 * 
	 * @param	OldObject	The object you want to replace.
	 * @param	NewObject	The new object you want to use instead.
	 * 
	 * @return	The new object.
	 ]]></haxe_doc>
		</replace>
		<remove public="1" set="method" line="67">
			<f a="Object:?Splice">
				<c path="haxel.HxlObject"/>
				<e path="Bool"/>
				<c path="haxel.HxlObject"/>
			</f>
			<haxe_doc><![CDATA[
	 * Removes an object from the group.
	 * 
	 * @param	Object	The <code>HxlObject</code> you want to remove.
	 * @param	Splice	Whether the object should be cut from the array entirely or not.
	 * 
	 * @return	The removed object.
	 ]]></haxe_doc>
		</remove>
		<getFirstAvail public="1" set="method" line="93">
			<f a=""><c path="haxel.HxlObject"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to retrieve the first object with exists == false in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * 
	 * @return	A <code>HxlObject</code> currently flagged as not existing.
	 ]]></haxe_doc>
		</getFirstAvail>
		<getFirstNull public="1" set="method" line="111">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to retrieve the first index set to 'null'.
	 * Returns -1 if no index stores a null object.
	 * 
	 * @return	An <code>int</code> indicating the first null slot in the group.
	 ]]></haxe_doc>
		</getFirstNull>
		<resetFirstAvail public="1" set="method" line="129">
			<f a="?X:?Y">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Finds the first object with exists == false and calls reset on it.
	 * 
	 * @param	X	The new X position of this object.
	 * @param	Y	The new Y position of this object.
	 * 
	 * @return	Whether a suitable <code>HxlObject</code> was found and reset.
	 ]]></haxe_doc>
		</resetFirstAvail>
		<getFirstExtant public="1" set="method" line="144">
			<f a=""><c path="haxel.HxlObject"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to retrieve the first object with exists == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>HxlObject</code> currently flagged as existing.
	 ]]></haxe_doc>
		</getFirstExtant>
		<getFirstAlive public="1" set="method" line="162">
			<f a=""><c path="haxel.HxlObject"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to retrieve the first object with dead == false in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>HxlObject</code> currently flagged as not dead.
	 ]]></haxe_doc>
		</getFirstAlive>
		<getFirstDead public="1" set="method" line="180">
			<f a=""><c path="haxel.HxlObject"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to retrieve the first object with dead == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>HxlObject</code> currently flagged as dead.
	 ]]></haxe_doc>
		</getFirstDead>
		<countLiving public="1" set="method" line="197">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to find out how many members of the group are not dead.
	 * 
	 * @return	The number of <code>HxlObject</code>s flagged as not dead.  Returns -1 if group is empty.
	 ]]></haxe_doc>
		</countLiving>
		<countDead public="1" set="method" line="220">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Call this function to find out how many members of the group are dead.
	 * 
	 * @return	The number of <code>HxlObject</code>s flagged as dead.  Returns -1 if group is empty.
	 ]]></haxe_doc>
		</countDead>
		<countOnScreen public="1" set="method" line="243">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Returns a count of how many objects in this group are on-screen right now.
	 * 
	 * @return	The number of <code>HxlObject</code>s that are on screen.  Returns -1 if group is empty.
	 ]]></haxe_doc>
		</countOnScreen>
		<countVisible public="1" set="method" line="266">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Returns a count of how many objects in this group have visible set to true.
	 *
	 * @return Int
	 </haxe_doc>
		</countVisible>
		<getRandom public="1" set="method" line="290">
			<f a=""><c path="haxel.HxlObject"/></f>
			<haxe_doc><![CDATA[
	 * Returns a member at random from the group.
	 * 
	 * @return	A <code>HxlObject</code> from the members list.
	 ]]></haxe_doc>
		</getRandom>
		<saveOldPosition set="method" line="305">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function, helps with the moving/updating of group members.
	 </haxe_doc>
		</saveOldPosition>
		<updateMembers set="method" line="320">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Internal function that actually goes through and updates all the group members.
	 * Depends on <code>saveOldPosition()</code> to set up the correct values in <code>_last</code> in order to work properly.
	 ]]></haxe_doc>
		</updateMembers>
		<update public="1" set="method" line="367" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Automatically goes through and calls update on everything you added,
	 * override this function to handle custom input and perform collisions.
	 </haxe_doc>
		</update>
		<renderMembers set="method" line="377">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that actually loops through and renders all the group members.
	 </haxe_doc>
		</renderMembers>
		<destroyMembers set="method" line="394">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that actually loops through and destroys each member.
	 </haxe_doc>
		</destroyMembers>
		<destroy public="1" set="method" line="411" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Override this function to handle any deleting or "shutdown" type operations you might need,
	 * such as removing traditional Flash children like Sprite objects.
	 </haxe_doc>
		</destroy>
		<render public="1" set="method" line="420" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Automatically goes through and calls render on everything you added,
	 * override this loop to control render order manually.
	 </haxe_doc>
		</render>
		<killMembers set="method" line="427">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that calls kill on all members.
	 </haxe_doc>
		</killMembers>
		<kill public="1" set="method" line="441" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Calls kill on the group and all its members.
	 </haxe_doc>
		</kill>
		<sortMembersByZIndex public="1" set="method" line="457"><f a=""><e path="Void"/></f></sortMembersByZIndex>
		<new public="1" set="method" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxel.HxlDialog" params="" file="../haxel/HxlDialog.hx">
		<extends path="haxel.HxlGroup"/>
		<add public="1" set="method" line="16" override="1"><f a="Object:?ShareScroll">
	<c path="haxel.HxlObject"/>
	<e path="Bool"/>
	<c path="haxel.HxlObject"/>
</f></add>
		<replace public="1" set="method" line="21" override="1"><f a="OldObject:NewObject">
	<c path="haxel.HxlObject"/>
	<c path="haxel.HxlObject"/>
	<c path="haxel.HxlObject"/>
</f></replace>
		<update public="1" set="method" line="28" override="1"><f a=""><e path="Void"/></f></update>
		<new public="1" set="method" line="6"><f a="?X:?Y:?Width:?Height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\Motion-Twin\haxe/std/flash9/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="String" params="" file="C:\Motion-Twin\haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Hash" params="T" file="C:\Motion-Twin\haxe/std/flash9/_std/Hash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="flash.media.Microphone" params="" file="C:\Motion-Twin\haxe/std/flash9/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<codec public="1"><e path="flash.media.SoundCodec"/></codec>
		<enableVAD public="1"><e path="Bool"/></enableVAD>
		<encodeQuality public="1"><c path="Int"/></encodeQuality>
		<enhancedOptions public="1"><c path="flash.media.MicrophoneEnhancedOptions"/></enhancedOptions>
		<framesPerPacket public="1"><c path="Int"/></framesPerPacket>
		<gain public="1"><c path="Float"/></gain>
		<index public="1" set="null"><c path="Int"/></index>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<name public="1" set="null"><c path="String"/></name>
		<noiseSuppressionLevel public="1"><c path="Int"/></noiseSuppressionLevel>
		<rate public="1"><c path="Int"/></rate>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Array" params="T" file="C:\Motion-Twin\haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="flash.text.StyleSheet" params="" file="C:\Motion-Twin\haxe/std/flash9/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\Motion-Twin\haxe/std/flash9/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="C:\Motion-Twin\haxe/std/flash9/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><c path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<blendShader public="1" get="null"><c path="flash.display.Shader"/></blendShader>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><d/></c></filters>
		<height public="1"><c path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><c path="Float"/></rotation>
		<rotationX public="1"><c path="Float"/></rotationX>
		<rotationY public="1"><c path="Float"/></rotationY>
		<rotationZ public="1"><c path="Float"/></rotationZ>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleZ public="1"><c path="Float"/></scaleZ>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><e path="Bool"/></visible>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<z public="1"><c path="Float"/></z>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<globalToLocal3D public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Vector3D"/>
</f></globalToLocal3D>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<local3DToGlobal public="1" set="method"><f a="point3d">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Point"/>
</f></local3DToGlobal>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\Motion-Twin\haxe/std/flash9/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\haxe/std/flash9/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<startTouchDrag public="1"><f a="touchPointID:?lockCenter:?bounds">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<stopTouchDrag public="1"><f a="touchPointID">
	<c path="Int"/>
	<e path="Void"/>
</f></stopTouchDrag>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\Motion-Twin\haxe/std/flash9/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<currentFrameLabel public="1" set="null"><c path="String"/></currentFrameLabel>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><e path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.net.SharedObjectFlushStatus" params="" file="C:\Motion-Twin\haxe/std/flash9/net/SharedObjectFlushStatus.hx">
		<PENDING/>
		<FLUSHED/>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxel.HxlKeyboard" params="" file="../haxel/HxlKeyboard.hx">
		<ESCAPE public="1"><e path="Bool"/></ESCAPE>
		<F1 public="1"><e path="Bool"/></F1>
		<F2 public="1"><e path="Bool"/></F2>
		<F3 public="1"><e path="Bool"/></F3>
		<F4 public="1"><e path="Bool"/></F4>
		<F5 public="1"><e path="Bool"/></F5>
		<F6 public="1"><e path="Bool"/></F6>
		<F7 public="1"><e path="Bool"/></F7>
		<F8 public="1"><e path="Bool"/></F8>
		<F9 public="1"><e path="Bool"/></F9>
		<F10 public="1"><e path="Bool"/></F10>
		<F11 public="1"><e path="Bool"/></F11>
		<F12 public="1"><e path="Bool"/></F12>
		<ONE public="1"><e path="Bool"/></ONE>
		<TWO public="1"><e path="Bool"/></TWO>
		<THREE public="1"><e path="Bool"/></THREE>
		<FOUR public="1"><e path="Bool"/></FOUR>
		<FIVE public="1"><e path="Bool"/></FIVE>
		<SIX public="1"><e path="Bool"/></SIX>
		<SEVEN public="1"><e path="Bool"/></SEVEN>
		<EIGHT public="1"><e path="Bool"/></EIGHT>
		<NINE public="1"><e path="Bool"/></NINE>
		<ZERO public="1"><e path="Bool"/></ZERO>
		<MINUS public="1"><e path="Bool"/></MINUS>
		<PLUS public="1"><e path="Bool"/></PLUS>
		<DELETE public="1"><e path="Bool"/></DELETE>
		<BACKSPACE public="1"><e path="Bool"/></BACKSPACE>
		<Q public="1"><e path="Bool"/></Q>
		<W public="1"><e path="Bool"/></W>
		<E public="1"><e path="Bool"/></E>
		<R public="1"><e path="Bool"/></R>
		<T public="1"><e path="Bool"/></T>
		<Y public="1"><e path="Bool"/></Y>
		<U public="1"><e path="Bool"/></U>
		<I public="1"><e path="Bool"/></I>
		<O public="1"><e path="Bool"/></O>
		<P public="1"><e path="Bool"/></P>
		<LBRACKET public="1"><e path="Bool"/></LBRACKET>
		<RBRACKET public="1"><e path="Bool"/></RBRACKET>
		<BACKSLASH public="1"><e path="Bool"/></BACKSLASH>
		<CAPSLOCK public="1"><e path="Bool"/></CAPSLOCK>
		<A public="1"><e path="Bool"/></A>
		<S public="1"><e path="Bool"/></S>
		<D public="1"><e path="Bool"/></D>
		<F public="1"><e path="Bool"/></F>
		<G public="1"><e path="Bool"/></G>
		<H public="1"><e path="Bool"/></H>
		<J public="1"><e path="Bool"/></J>
		<K public="1"><e path="Bool"/></K>
		<L public="1"><e path="Bool"/></L>
		<SEMICOLON public="1"><e path="Bool"/></SEMICOLON>
		<QUOTE public="1"><e path="Bool"/></QUOTE>
		<ENTER public="1"><e path="Bool"/></ENTER>
		<SHIFT public="1"><e path="Bool"/></SHIFT>
		<Z public="1"><e path="Bool"/></Z>
		<X public="1"><e path="Bool"/></X>
		<C public="1"><e path="Bool"/></C>
		<V public="1"><e path="Bool"/></V>
		<B public="1"><e path="Bool"/></B>
		<N public="1"><e path="Bool"/></N>
		<M public="1"><e path="Bool"/></M>
		<COMMA public="1"><e path="Bool"/></COMMA>
		<PERIOD public="1"><e path="Bool"/></PERIOD>
		<SLASH public="1"><e path="Bool"/></SLASH>
		<CONTROL public="1"><e path="Bool"/></CONTROL>
		<ALT public="1"><e path="Bool"/></ALT>
		<SPACE public="1"><e path="Bool"/></SPACE>
		<UP public="1"><e path="Bool"/></UP>
		<DOWN public="1"><e path="Bool"/></DOWN>
		<LEFT public="1"><e path="Bool"/></LEFT>
		<RIGHT public="1"><e path="Bool"/></RIGHT>
		<_lookup>
			<d/>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</_lookup>
		<_map>
			<c path="Array"><d/></c>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</_map>
		<_t>
			<c path="Int"/>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</_t>
		<update public="1" set="method" line="165">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates the key states (for tracking just pressed, just released, etc).
	 </haxe_doc>
		</update>
		<reset public="1" set="method" line="181">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resets all the keys.
	 </haxe_doc>
		</reset>
		<pressed public="1" set="method" line="198">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check to see if this key is pressed.
	 * 
	 * @param	Key		One of the key constants listed above (e.g. "LEFT" or "A").
	 * 
	 * @return	Whether the key is pressed
	 </haxe_doc>
		</pressed>
		<justPressed public="1" set="method" line="207">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check to see if this key was just pressed.
	 * 
	 * @param	Key		One of the key constants listed above (e.g. "LEFT" or "A").
	 * 
	 * @return	Whether the key was just pressed
	 </haxe_doc>
		</justPressed>
		<justReleased public="1" set="method" line="216">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check to see if this key is just released.
	 * 
	 * @param	Key		One of the key constants listed above (e.g. "LEFT" or "A").
	 * 
	 * @return	Whether the key is just released.
	 </haxe_doc>
		</justReleased>
		<handleKeyDown public="1" set="method" line="223">
			<f a="event">
				<c path="flash.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Event handler so HxlGame can toggle keys.
	 * 
	 * @param	event	A <code>KeyboardEvent</code> object.
	 ]]></haxe_doc>
		</handleKeyDown>
		<handleKeyUp public="1" set="method" line="240">
			<f a="event">
				<c path="flash.events.KeyboardEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Event handler so HxlGame can toggle keys.
	 * 
	 * @param	event	A <code>KeyboardEvent</code> object.
	 ]]></haxe_doc>
		</handleKeyUp>
		<addKey set="method" line="257">
			<f a="KeyName:KeyCode">
				<c path="String"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * An internal helper function used to build the key array.
	 * 
	 * @param	KeyName		String name of the key (e.g. "LEFT" or "A")
	 * @param	KeyCode		The numeric Flash code for this key.
	 </haxe_doc>
		</addKey>
		<new public="1" set="method" line="95">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor
	 </haxe_doc>
		</new>
	</class>
	<class path="flash.display.NativeMenu" params="" file="C:\Motion-Twin\haxe/std/flash9/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxel.HxlPause" params="" file="../haxel/HxlPause.hx">
		<extends path="haxel.HxlGroup"/>
		<ImgKeyMinus><c path="Class"><c path="flash.display.Bitmap"/></c></ImgKeyMinus>
		<ImgKeyPlus><c path="Class"><c path="flash.display.Bitmap"/></c></ImgKeyPlus>
		<ImgKey0><c path="Class"><c path="flash.display.Bitmap"/></c></ImgKey0>
		<ImgKeyP><c path="Class"><c path="flash.display.Bitmap"/></c></ImgKeyP>
		<new public="1" set="method" line="25">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<loop public="1"><e path="Bool"/></loop>
		<play public="1"><e path="Bool"/></play>
		<print public="1"><e path="Bool"/></print>
		<quality public="1"><e path="Bool"/></quality>
		<rewind public="1"><e path="Bool"/></rewind>
		<save public="1"><e path="Bool"/></save>
		<zoom public="1"><e path="Bool"/></zoom>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.Boot" params="" file="C:\Motion-Twin\haxe/std/flash9/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="53" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="84" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="93" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="103" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="111" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="115" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="134" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="149" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="191" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<start set="method" line="55"><f a=""><e path="Void"/></f></start>
		<doInitDelay set="method" line="75"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<init set="method" line="80"><f a=""><e path="Void"/></f></init>
		<new public="1" set="method" line="47"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="C:\Motion-Twin\haxe/std/flash9/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.CapsStyle" params="" file="C:\Motion-Twin\haxe/std/flash9/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="C:\Motion-Twin\haxe/std/flash9/display/FrameLabel.hx" extern="1">
		<frame public="1" set="null"><c path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.GenericActuator" params="" file="../com/eclecticdesignstudio/motion/actuators/GenericActuator.hx">
		<duration><c path="Float"/></duration>
		<id><c path="String"/></id>
		<properties><d/></properties>
		<target><d/></target>
		<_autoVisible><e path="Bool"/></_autoVisible>
		<_delay><c path="Float"/></_delay>
		<_ease><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></_ease>
		<_onUpdate><f a="">
	<d/>
	<d/>
</f></_onUpdate>
		<_onUpdateParams><d/></_onUpdateParams>
		<_onComplete><d/></_onComplete>
		<_onCompleteParams><c path="Array"><d/></c></_onCompleteParams>
		<_reflect><e path="Bool"/></_reflect>
		<_repeat><c path="Int"/></_repeat>
		<_reverse><e path="Bool"/></_reverse>
		<_smartRotation><e path="Bool"/></_smartRotation>
		<_snapping><e path="Bool"/></_snapping>
		<special><e path="Bool"/></special>
		<getProperties public="1" set="method" line="58"><f a=""><d/></f></getProperties>
		<apply set="method" line="62"><f a=""><e path="Void"/></f></apply>
		<autoVisible public="1" set="method" line="78">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Flash performs faster when objects are set to visible = false rather than only alpha = 0. autoVisible toggles automatically based on alpha values
	 * @param	value		Whether autoVisible should be enabled (Default is true)
	 * @return		The current actuator instance
	 </haxe_doc>
		</autoVisible>
		<change set="method" line="87"><f a=""><e path="Void"/></f></change>
		<complete set="method" line="98"><f a="?sendEvent">
	<e path="Bool"/>
	<e path="Void"/>
</f></complete>
		<delay public="1" set="method" line="124">
			<f a="duration">
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Increases the delay before a tween is executed
	 * @param	duration		The amount of seconds to delay
	 * @return		The current actuator instance
	 </haxe_doc>
		</delay>
		<ease public="1" set="method" line="138">
			<f a="easing">
				<c path="com.eclecticdesignstudio.motion.easing.IEasing"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Sets the easing which is used when running the tween
	 * @param	easing		An easing equation, like Elastic.easeIn or Quad.easeOut
	 * @return		The current actuator instance
	 </haxe_doc>
		</ease>
		<move set="method" line="147"><f a=""><e path="Void"/></f></move>
		<onUpdate public="1" set="method" line="160">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Defines a function which will be called when the tween updates
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance
	 </haxe_doc>
		</onUpdate>
		<onComplete public="1" set="method" line="176">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Defines a function which will be called when the tween finishes
	 * @param	handler		The function you would like to be called
	 * @param	parameters		Parameters you would like to pass to the handler function when it is called
	 * @return		The current actuator instance
	 </haxe_doc>
		</onComplete>
		<pause set="method" line="192"><f a=""><e path="Void"/></f></pause>
		<reflect public="1" set="method" line="204">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Automatically changes the reverse value when the tween repeats. Repeat must be enabled for this to have any effect
	 * @param	value		Whether reflect should be enabled (Default is true)
	 * @return		The current actuator instance
	 </haxe_doc>
		</reflect>
		<repeat public="1" set="method" line="219">
			<f a="?times">
				<c path="Int"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Repeats the tween after it finishes
	 * @param	times		The number of times you would like the tween to repeat, or -1 if you would like to repeat the tween indefinitely (Default is -1)
	 * @return		The current actuator instance
	 </haxe_doc>
		</repeat>
		<resume set="method" line="228"><f a=""><e path="Void"/></f></resume>
		<reverse public="1" set="method" line="240">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Sets if the tween should be handled in reverse
	 * @param	value		Whether the tween should be reversed (Default is true)
	 * @return		The current actuator instance
	 </haxe_doc>
		</reverse>
		<smartRotation public="1" set="method" line="255">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Enabling smartRotation can prevent undesired results when tweening rotation values
	 * @param	value		Whether smart rotation should be enabled (Default is true)
	 * @return		The current actuator instance
	 </haxe_doc>
		</smartRotation>
		<snapping public="1" set="method" line="270">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * Snapping causes tween values to be rounded automatically
	 * @param	value		Whether tween values should be rounded (Default is true)
	 * @return		The current actuator instance
	 </haxe_doc>
		</snapping>
		<stop set="method" line="280"><f a="properties:complete:sendEvent">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<new public="1" set="method" line="38"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * @author Joshua Granick
 * @version 1.2
 </haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.actuators.SimpleActuator" params="" file="../com/eclecticdesignstudio/motion/actuators/SimpleActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
		<actuators line="21" static="1"><c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/></c></actuators>
		<actuatorsLength line="22" static="1"><c path="Int"/></actuatorsLength>
		<shape static="1"><c path="flash.display.Shape"/></shape>
		<shape_onEnterFrame set="method" line="354" static="1"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></shape_onEnterFrame>
		<timeOffset><c path="Float"/></timeOffset>
		<active><e path="Bool"/></active>
		<cacheVisible><e path="Bool"/></cacheVisible>
		<detailsLength><c path="Int"/></detailsLength>
		<initialized><e path="Bool"/></initialized>
		<paused><e path="Bool"/></paused>
		<pauseTime><c path="Float"/></pauseTime>
		<propertyDetails><c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.PropertyDetails"/></c></propertyDetails>
		<sendChange><e path="Bool"/></sendChange>
		<setVisible><e path="Bool"/></setVisible>
		<startTime><c path="Float"/></startTime>
		<toggleVisible><e path="Bool"/></toggleVisible>
		<autoVisible public="1" set="method" line="65" override="1">
			<f a="?value">
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * @inheritDoc
	 </haxe_doc>
		</autoVisible>
		<delay public="1" set="method" line="89" override="1">
			<f a="duration">
				<c path="Float"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * @inheritDoc
	 </haxe_doc>
		</delay>
		<initialize set="method" line="99"><f a=""><e path="Void"/></f></initialize>
		<move set="method" line="117" override="1"><f a=""><e path="Void"/></f></move>
		<onUpdate public="1" set="method" line="139" override="1">
			<f a="handler:?parameters">
				<d/>
				<c path="Array"><d/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc>
	 * @inheritDoc
	 </haxe_doc>
		</onUpdate>
		<pause set="method" line="150" override="1"><f a=""><e path="Void"/></f></pause>
		<resume set="method" line="158" override="1"><f a=""><e path="Void"/></f></resume>
		<stop set="method" line="170" override="1"><f a="properties:complete:sendEvent">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<update set="method" line="213"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<new public="1" set="method" line="38"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * @author Joshua Granick
 * @version 1.2
 </haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.Linear" params="" file="../com/eclecticdesignstudio/motion/easing/Linear.hx">
		<easeNone public="1" get="getEaseNone" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeNone>
		<getEaseNone set="method" line="17" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseNone>
		<haxe_doc>
 * @author Joshua Granick
 * @author Philippe / http://philippe.elsass.me
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 </haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.IEasing" params="" file="../com/eclecticdesignstudio/motion/easing/IEasing.hx" interface="1">
		<calculate public="1" set="method"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<ease public="1" set="method"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<haxe_doc>
	 * @author Joshua Granick
	 * @author Philippe / http://philippe.elsass.me
	 </haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.LinearEaseNone" params="" file="../com/eclecticdesignstudio/motion/easing/Linear.hx" module="com.eclecticdesignstudio.motion.easing.Linear">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<calculate public="1" set="method" line="37"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="44"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.Actuate" params="" file="../com/eclecticdesignstudio/motion/Actuate.hx">
		<defaultActuator public="1" line="27" static="1"><c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c></defaultActuator>
		<defaultEase public="1" line="28" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></defaultEase>
		<targetLibraries line="29" static="1"><c path="Hash"><c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c></c></targetLibraries>
		<apply public="1" set="method" line="40" static="1">
			<f a="target:properties:?customActuator">
				<d/>
				<d/>
				<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc><![CDATA[
	 * Copies properties from one object to another. Conflicting tweens are stopped automatically
	 * @example		<code>Actuate.apply (MyClip, { alpha: 1 } );</code>
	 * @param	target		The object to copy to
	 * @param	properties		The object to copy from
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or onUpdate handlers
	 ]]></haxe_doc>
		</apply>
		<effects public="1" set="method" line="77" static="1">
			<f a="target:duration:?overwrite">
				<c path="flash.display.DisplayObject"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.EffectsOptions"/>
			</f>
			<haxe_doc>
	 * Creates a new effects tween 
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		An EffectsOptions instance, which is used to select the kind of effect you would like to apply to the target
	 </haxe_doc>
		</effects>
		<getLibrary set="method" line="84" static="1"><f a="target">
	<d/>
	<c path="Array"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
</f></getLibrary>
		<pause public="1" set="method" line="119" static="1">
			<f a="target">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pauses tweens for the specified target objects
	 * @param	... targets		The target objects which will have their tweens paused. Passing no value pauses tweens for all objects
	 </haxe_doc>
		</pause>
		<pauseAll public="1" set="method" line="141" static="1"><f a=""><e path="Void"/></f></pauseAll>
		<reset public="1" set="method" line="160" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resets Actuate by stopping and removing tweens for all objects
	 </haxe_doc>
		</reset>
		<resume public="1" set="method" line="184" static="1">
			<f a="target">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Resumes paused tweens for the specified target objects
	 * @param	... targets		The target objects which will have their tweens resumed. Passing no value resumes tweens for all objects
	 </haxe_doc>
		</resume>
		<resumeAll public="1" set="method" line="206" static="1"><f a=""><e path="Void"/></f></resumeAll>
		<stop public="1" set="method" line="228" static="1">
			<f a="target:?properties:?complete">
				<d/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Stops all tweens for an individual object
	 * @param	target		The target object which will have its tweens stopped
	 * @param  properties		A string, array or object which contains the properties you wish to stop, like "alpha", [ "x", "y" ] or { alpha: null }. Passing no value removes all tweens for the object (Optional)
	 * @param	complete		If tweens should apply their final target values before stopping. Default is false (Optional) 
	 </haxe_doc>
		</stop>
		<timer public="1" set="method" line="279" static="1">
			<f a="duration:?customActuator">
				<c path="Float"/>
				<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a tween-based timer, which is useful for synchronizing function calls with other animations
	 * @example		<code>Actuate.timer (1).onComplete (trace, "Timer is now complete");</code>
	 * @param	duration		The length of the timer in seconds
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like onComplete or to gain a reference to the target timer object
	 ]]></haxe_doc>
		</timer>
		<transform public="1" set="method" line="294" static="1">
			<f a="target:?duration:?overwrite">
				<d/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.TransformOptions"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a new transform tween
	 * @example		<code>Actuate.transform (MyClip, 1).color (0xFF0000);</code>
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		A TransformOptions instance, which is used to select the kind of transform you would like to apply to the target
	 ]]></haxe_doc>
		</transform>
		<tween public="1" set="method" line="311" static="1">
			<f a="target:duration:properties:?overwrite:?customActuator">
				<d/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<c path="Class"><c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/></c>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a new tween
	 * @example		<code>Actuate.tween (MyClip, 1, { alpha: 1 } ).onComplete (trace, "MyClip is now visible");</code>
	 * @param	target		The object to tween
	 * @param	duration		The length of the tween in seconds
	 * @param	properties		The end values to tween the target to
	 * @param	overwrite			Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @param	customActuator		A custom actuator to use instead of the default (Optional)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate
	 ]]></haxe_doc>
		</tween>
		<unload set="method" line="374" static="1"><f a="actuator">
	<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
	<e path="Void"/>
</f></unload>
		<update public="1" set="method" line="404" static="1">
			<f a="target:duration:?start:?end:?overwrite">
				<d/>
				<c path="Float"/>
				<d/>
				<d/>
				<e path="Bool"/>
				<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a new tween that updates a method rather than setting the properties of an object
	 * @example		<code>Actuate.update (trace, 1, ["Value: ", 0], ["", 1]).onComplete (trace, "Finished tracing values between 0 and 1");</code>
	 * @param	target		The method to update		
	 * @param	duration		The length of the tween in seconds
	 * @param	start		The starting parameters of the method call. You may use both numeric and non-numeric values
	 * @param	end		The ending parameters of the method call. You may use both numeric and non-numeric values, but the signature should match the start parameters
	 * @param	overwrite		Sets whether previous tweens for the same target and properties will be overwritten (Default is true)
	 * @return		The current actuator instance, which can be used to apply properties like ease, delay, onComplete or onUpdate
	 ]]></haxe_doc>
		</update>
		<haxe_doc>
 * @author Joshua Granick
 * @version 1.22
 </haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.EffectsOptions" params="" file="../com/eclecticdesignstudio/motion/Actuate.hx" module="com.eclecticdesignstudio.motion.Actuate">
		<duration><c path="Float"/></duration>
		<overwrite><e path="Bool"/></overwrite>
		<target><c path="flash.display.DisplayObject"/></target>
		<new public="1" set="method" line="434"><f a="target:duration:overwrite">
	<c path="flash.display.DisplayObject"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.TransformOptions" params="" file="../com/eclecticdesignstudio/motion/Actuate.hx" module="com.eclecticdesignstudio.motion.Actuate">
		<duration><c path="Float"/></duration>
		<overwrite><e path="Bool"/></overwrite>
		<target><d/></target>
		<new public="1" set="method" line="469"><f a="target:duration:overwrite">
	<d/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.TweenTimer" params="" file="../com/eclecticdesignstudio/motion/Actuate.hx" module="com.eclecticdesignstudio.motion.Actuate">
		<progress public="1"><c path="Float"/></progress>
		<new public="1" set="method" line="536"><f a="progress">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="com.eclecticdesignstudio.motion.ActuateInternal" params="" file="../com/eclecticdesignstudio/motion/Actuate.hx" module="com.eclecticdesignstudio.motion.Actuate"><a><unload set="method"><f a="actuator">
	<c path="com.eclecticdesignstudio.motion.actuators.GenericActuator"/>
	<e path="Void"/>
</f></unload></a></typedef>
	<class path="haxel.HxlList" params="" file="../haxel/HxlList.hx">
		<object public="1">
			<c path="haxel.HxlObject"/>
			<haxe_doc><![CDATA[
	 * Stores a reference to a <code>HxlObject</code>.
	 ]]></haxe_doc>
		</object>
		<next public="1">
			<c path="haxel.HxlList"/>
			<haxe_doc>
	 * Stores a reference to the next link in the list.
	 </haxe_doc>
		</next>
		<new public="1" set="method" line="24">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Creates a new link, and sets <code>object</code> and <code>next</code> to <code>null</null>.
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * The world's smallest linked list class.
 * Useful for optimizing time-critical or highly repetitive tasks!
 * See <code>HxlQuadTree</code> for how to use it, IF YOU DARE.
 ]]></haxe_doc>
	</class>
	<class path="flash.display.IGraphicsData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/IGraphicsData.hx" extern="1" interface="1"/>
	<class path="flash.geom.Transform" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<matrix3D public="1"><c path="flash.geom.Matrix3D"/></matrix3D>
		<perspectiveProjection public="1"><c path="flash.geom.PerspectiveProjection"/></perspectiveProjection>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<getRelativeMatrix3D public="1" set="method"><f a="relativeTo">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Matrix3D"/>
</f></getRelativeMatrix3D>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.ui.MouseCursor" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/MouseCursor.hx">
		<IBEAM/>
		<HAND/>
		<BUTTON/>
		<AUTO/>
		<ARROW/>
	</enum>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
	</enum>
	<class path="Class" params="T" file="C:\Motion-Twin\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<enum path="flash.display.GradientType" params="" file="C:\Motion-Twin\haxe/std/flash9/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
	</enum>
	<class path="haxel.HxlAnim" params="" file="../haxel/HxlAnim.hx">
		<name public="1">
			<c path="String"/>
			<haxe_doc>
	 * String name of the animation (e.g. "walk")
	 </haxe_doc>
		</name>
		<delay public="1">
			<c path="Float"/>
			<haxe_doc>
	 * Seconds between frames (basically the framerate)
	 </haxe_doc>
		</delay>
		<frames public="1">
			<c path="Array"><c path="Int"/></c>
			<haxe_doc><![CDATA[
	 * A list of frames stored as <code>Int</code> objects
	 ]]></haxe_doc>
		</frames>
		<looped public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether or not the animation is looped
	 </haxe_doc>
		</looped>
		<new public="1" set="method" line="30">
			<f a="Name:Frames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><c path="Int"/></c>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor
	 * 
	 * @param	Name		What this animation should be called (e.g. "run")
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3)
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40)
	 * @param	Looped		Whether or not the animation is looped or just plays once
	 </haxe_doc>
		</new>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
	</enum>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\Motion-Twin\haxe/std/flash9/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><t path="UInt"/></errno>
		<stub public="1"><e path="Bool"/></stub>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.net.NetStreamAppendBytesAction" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamAppendBytesAction.hx">
		<RESET_SEEK/>
		<RESET_BEGIN/>
		<END_SEQUENCE/>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><c path="Float"/></ascent>
		<descent public="1"><c path="Float"/></descent>
		<height public="1"><c path="Float"/></height>
		<leading public="1"><c path="Float"/></leading>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
	</enum>
	<class path="haxel.HxlTimer" params="" file="../haxel/HxlTimer.hx">
		<_game static="1"><c path="haxel.HxlGame"/></_game>
		<_total public="1" line="6" static="1"><c path="Float"/></_total>
		<setGameData public="1" set="method" line="12" static="1"><f a="Game">
	<c path="haxel.HxlGame"/>
	<e path="Void"/>
</f></setGameData>
		<target><c path="Float"/></target>
		<base><c path="Float"/></base>
		<last><c path="Float"/></last>
		<delta public="1" set="method" line="25">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * Returns the time (in seconds) relative to the target time.
	 </haxe_doc>
		</delta>
		<new public="1" set="method" line="16"><f a="?Target">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\Motion-Twin\haxe/std/flash9/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1"><t path="UInt"/></MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<domainMemory public="1"><c path="flash.utils.ByteArray"/></domainMemory>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxel.HxlConsole" params="" file="../haxel/HxlConsole.hx">
		<extends path="flash.display.Sprite"/>
		<mtrUpdate public="1"><c path="haxel.HxlMonitor"/></mtrUpdate>
		<mtrRender public="1"><c path="haxel.HxlMonitor"/></mtrRender>
		<mtrTotal public="1"><c path="haxel.HxlMonitor"/></mtrTotal>
		<_max_lines><c path="Int"/></_max_lines>
		<_console><c path="flash.display.Sprite"/></_console>
		<_lines><c path="Array"><c path="String"/></c></_lines>
		<_text><c path="flash.text.TextField"/></_text>
		<_fpsDisplay><c path="flash.text.TextField"/></_fpsDisplay>
		<_extraDisplay><c path="flash.text.TextField"/></_extraDisplay>
		<_memDisplay><c path="flash.text.TextField"/></_memDisplay>
		<_curFPS><c path="Int"/></_curFPS>
		<_rendersDisplay><c path="flash.text.TextField"/></_rendersDisplay>
		<_Y><c path="Float"/></_Y>
		<_YT><c path="Float"/></_YT>
		<_bx><c path="Int"/></_bx>
		<_by><c path="Int"/></_by>
		<_byt><c path="Int"/></_byt>
		<toggle public="1" set="method" line="151"><f a=""><e path="Void"/></f></toggle>
		<log public="1" set="method" line="165">
			<f a="Text">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Logs a string to the console
	 *
	 * @param	Text	String of text to log to the console
	 </haxe_doc>
		</log>
		<update public="1" set="method" line="185"><f a=""><e path="Void"/></f></update>
		<new public="1" set="method" line="45">
			<f a="X:Y:Zoom:?DefaultFont">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor
	 *
	 * @param	X	X position of the console
	 * @param	Y	Y position of the console
	 </haxe_doc>
		</new>
	</class>
	<class path="flash.Lib" params="" file="C:\Motion-Twin\haxe/std/flash9/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\Motion-Twin\haxe/std/flash9/xml/XMLList.hx" extern="1">
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.Font" params="" file="C:\Motion-Twin\haxe/std/flash9/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="FontSystem" params="" file="Resources.hx" module="Resources">
		<extends path="flash.text.Font"/>
		<new public="1" set="method" line="5"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Resources" params="" file="Resources.hx"/>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\Motion-Twin\haxe/std/flash9/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><e path="Bool"/></silent>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\Motion-Twin\haxe/std/flash9/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\Motion-Twin\haxe/std/flash9/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<enum path="flash.display.PixelSnapping" params="" file="C:\Motion-Twin\haxe/std/flash9/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
	</enum>
	<class path="flash.net.NetStreamInfo" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamInfo.hx" extern="1">
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoLossRate public="1"><c path="Float"/></videoLossRate>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="com.eclecticdesignstudio.motion.actuators.MotionInternal" params="" file="../com/eclecticdesignstudio/motion/actuators/GenericActuator.hx" module="com.eclecticdesignstudio.motion.actuators.GenericActuator"><a>
	<target><d/></target>
	<stop set="method"><f a="properties:complete:sendEvent">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
	<resume set="method"><f a=""><e path="Void"/></f></resume>
	<properties><d/></properties>
	<pause set="method"><f a=""><e path="Void"/></f></pause>
	<move set="method"><f a=""><e path="Void"/></f></move>
	<duration><c path="Float"/></duration>
	<apply set="method"><f a=""><e path="Void"/></f></apply>
</a></typedef>
	<class path="haxel.HxlSprite" params="" file="../haxel/HxlSprite.hx">
		<extends path="haxel.HxlObject"/>
		<LEFT public="1" line="26" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Useful for controlling flipped animations and checking player orientation.
	 </haxe_doc>
		</LEFT>
		<RIGHT public="1" line="30" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Useful for controlling flipped animations and checking player orientation.
	 </haxe_doc>
		</RIGHT>
		<UP public="1" line="34" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Useful for checking player orientation.
	 </haxe_doc>
		</UP>
		<DOWN public="1" line="38" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Useful for checking player orientation.
	 </haxe_doc>
		</DOWN>
		<alpha public="1" get="getAlpha" set="setAlpha"><c path="Float"/></alpha>
		<color public="1" get="getColor" set="setColor"><c path="Int"/></color>
		<facing public="1" get="getFacing" set="setFacing"><c path="Int"/></facing>
		<frame public="1" get="getFrame" set="setFrame"><c path="Int"/></frame>
		<pixels public="1" get="getPixels" set="setPixels"><c path="flash.display.BitmapData"/></pixels>
		<frameWidth public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The width of the actual graphic or image being displayed (not necessarily the game object/bounding box).
	 * NOTE: Edit at your own risk!!  This is intended to be read-only.
	 </haxe_doc>
		</frameWidth>
		<frameHeight public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The height of the actual graphic or image being displayed (not necessarily the game object/bounding box).
	 * NOTE: Edit at your own risk!!  This is intended to be read-only.
	 </haxe_doc>
		</frameHeight>
		<offset public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	* If you changed the size of your sprite object to shrink the bounding box,
	* you might need to offset the new bounding box from the top-left corner of the sprite.
	</haxe_doc>
		</offset>
		<blend public="1">
			<c path="String"/>
			<haxe_doc>
	 * Blending modes, just like Photoshop!
	 * E.g. "multiply", "screen", etc.
	 * @default null
	 </haxe_doc>
		</blend>
		<scale public="1">
			<c path="haxel.HxlPoint"/>
			<haxe_doc>
	 * Change the size of your sprite's graphic.
	 * NOTE: Scale doesn't currently affect collisions automatically,
	 * you will need to adjust the width, height and offset manually.
	 * WARNING: scaling sprites decreases rendering performance for this sprite by a factor of 10x!
	 </haxe_doc>
		</scale>
		<antialiasing public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Controls whether the object is smoothed when rotated, affects performance.
	 * @default false
	 </haxe_doc>
		</antialiasing>
		<finished public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether the current animation has finished its first (or only) loop.
	 </haxe_doc>
		</finished>
		<_animations><c path="Array"><c path="haxel.HxlAnim"/></c></_animations>
		<_flipped><c path="Int"/></_flipped>
		<_curAnim><c path="haxel.HxlAnim"/></_curAnim>
		<_curFrame><c path="Int"/></_curFrame>
		<_caf><c path="Int"/></_caf>
		<_frameTimer><c path="Float"/></_frameTimer>
		<_callback><d/></_callback>
		<_facing><c path="Int"/></_facing>
		<_bakedRotation><c path="Float"/></_bakedRotation>
		<_flashRect><c path="flash.geom.Rectangle"/></_flashRect>
		<_flashRect2><c path="flash.geom.Rectangle"/></_flashRect2>
		<_flashPointZero><c path="flash.geom.Point"/></_flashPointZero>
		<_pixels><c path="flash.display.BitmapData"/></_pixels>
		<_framePixels><c path="flash.display.BitmapData"/></_framePixels>
		<_alpha><c path="Float"/></_alpha>
		<_color><c path="Int"/></_color>
		<_ct><c path="flash.geom.ColorTransform"/></_ct>
		<_mtx><c path="flash.geom.Matrix"/></_mtx>
		<_bbb><c path="flash.display.BitmapData"/></_bbb>
		<alphaVelocity public="1"><c path="Float"/></alphaVelocity>
		<scaleVelocity public="1"><c path="haxel.HxlPoint"/></scaleVelocity>
		<createGraphic public="1" set="method" line="155">
			<f a="Width:Height:?Color:?Unique:?Key">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="haxel.HxlSprite"/>
			</f>
			<haxe_doc>
	 * This function creates a flat colored square image dynamically.
	 * 
	 * @param	Width		The width of the sprite you want to generate.
	 * @param	Height		The height of the sprite you want to generate.
	 * @param	Color		Specifies the color of the generated block.
	 * @param	Unique		Whether the graphic should be a unique instance in the graphics cache.
	 * @param	Key			Optional parameter - specify a string key to identify this graphic in the cache.  Trumps Unique flag.
	 * 
	 * @return	This HxlSprite instance (nice for chaining stuff together, if you're into that).
	 </haxe_doc>
		</createGraphic>
		<loadGraphic public="1" set="method" line="176">
			<f a="Graphic:?Animated:?Reverse:?Width:?Height:?Unique">
				<c path="Class"><c path="flash.display.Bitmap"/></c>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="haxel.HxlSprite"/>
			</f>
			<haxe_doc>
	 * Load an image from an embedded graphic file.
	 * 
	 * @param	Graphic		The image you want to use.
	 * @param	Animated	Whether the Graphic parameter is a single sprite or a row of sprites.
	 * @param	Reverse		Whether you need this class to generate horizontally flipped versions of the animation frames.
	 * @param	Width		OPTIONAL - Specify the width of your sprite (helps HxlSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Height		OPTIONAL - Specify the height of your sprite (helps HxlSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Unique		Whether the graphic should be a unique instance in the graphics cache.
	 * 
	 * @return	This HxlSprite instance (nice for chaining stuff together, if you're into that).
	 </haxe_doc>
		</loadGraphic>
		<loadRotatedGraphic public="1" set="method" line="218">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer">
				<c path="Class"><c path="flash.display.Bitmap"/></c>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="haxel.HxlSprite"/>
			</f>
			<haxe_doc><![CDATA[
	 * Create a pre-rotated sprite sheet from a simple sprite.
	 * This can make a huge difference in graphical performance!
	 * 
	 * @param	Graphic			The image you want to rotate & stamp.
	 * @param	Frames			The number of frames you want to use (more == smoother rotations).
	 * @param	Offset			Use this to select a specific frame to draw from the graphic.
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.
	 * 
	 * @return	This HxlSprite instance (nice for chaining stuff together, if you're into that).
	 ]]></haxe_doc>
		</loadRotatedGraphic>
		<draw public="1" set="method" line="291">
			<f a="Brush:?X:?Y">
				<c path="haxel.HxlSprite"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * This function draws or stamps one <code>HxlSprite</code> onto another.
	 * This function is NOT intended to replace <code>render()</code>!
	 * 
	 * @param	Brush		The image you want to use as a brush or stamp or pen or whatever.
	 * @param	X			The X coordinate of the brush's top left corner on this sprite.
	 * @param	Y			They Y coordinate of the brush's top left corner on this sprite.
	 ]]></haxe_doc>
		</draw>
		<renderSprite set="method" line="326">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that performs the actual sprite rendering, called by render().
	 </haxe_doc>
		</renderSprite>
		<render public="1" set="method" line="369" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by game loop, updates then blits or renders current frame of animation to the screen
	 </haxe_doc>
		</render>
		<update public="1" set="method" line="377" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Main game loop update function.  Override this to create your own sprite logic!
	 * Just don't forget to call super.update() or any of the helper functions.
	 </haxe_doc>
		</update>
		<updateAnimation set="method" line="388">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Internal function for updating the sprite's animation.
	 * Useful for cases when you need to update this but are buried down in too many supers.
	 * This function is called automatically by <code>HxlSprite.update()</code>.
	 ]]></haxe_doc>
		</updateAnimation>
		<resetHelpers set="method" line="453">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resets some important variables for sprite optimization and rendering.
	 </haxe_doc>
		</resetHelpers>
		<drawBounds set="method" line="480"><f a=""><e path="Void"/></f></drawBounds>
		<fill public="1" set="method" line="506">
			<f a="Color">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Fills this sprite's graphic with a specific color.
	 * 
	 * @param	Color		The color with which to fill the graphic, format 0xAARRGGBB.
	 </haxe_doc>
		</fill>
		<calcFrame set="method" line="513"><f a=""><e path="Void"/></f></calcFrame>
		<onEmit public="1" set="method" line="554">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Triggered whenever this sprite is launched by a <code>HxlEmitter</code>.
	 ]]></haxe_doc>
		</onEmit>
		<getAlpha public="1" set="method" line="559">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>alpha</code> to a number between 0 and 1 to change the opacity of the sprite.
	 ]]></haxe_doc>
		</getAlpha>
		<setAlpha public="1" set="method" line="566">
			<f a="Alpha">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setAlpha>
		<getColor public="1" set="method" line="582">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>color</code> to a number in this format: 0xRRGGBB.
	 * <code>color</code> IGNORES ALPHA.  To change the opacity use <code>alpha</code>.
	 * Tints the whole sprite to be this color (similar to OpenGL vertex colors).
	 ]]></haxe_doc>
		</getColor>
		<setColor public="1" set="method" line="589">
			<f a="Color">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setColor>
		<getFacing public="1" set="method" line="604">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>facing</code> using <code>HxlSprite.LEFT</code>,<code>RIGHT</code>,
	 * <code>UP</code>, and <code>DOWN</code> to take advantage of
	 * flipped sprites and/or just track player orientation more easily.
	 ]]></haxe_doc>
		</getFacing>
		<setFacing public="1" set="method" line="611">
			<f a="Direction">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setFacing>
		<addAnimation public="1" set="method" line="626">
			<f a="Name:Frames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><c path="Int"/></c>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Adds a new animation to the sprite.
	 * 
	 * @param	Name		What this animation should be called (e.g. "run").
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped		Whether or not the animation is looped or just plays once.
	 </haxe_doc>
		</addAnimation>
		<addAnimationCallback public="1" set="method" line="635">
			<f a="AnimationCallback">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Pass in a function to be called whenever this sprite's animation changes.
	 * 
	 * @param	AnimationCallback		A function that has 3 parameters: a string name, a Int frame number, and a Int frame index.
	 </haxe_doc>
		</addAnimationCallback>
		<play public="1" set="method" line="646">
			<f a="AnimName:?Force">
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Plays an existing animation (e.g. "run").
	 * If you call an animation that is already playing it will be ignored.
	 * 
	 * @param	AnimName	The string name of the animation you want to play.
	 * @param	Force		Whether to force the animation to restart.
	 </haxe_doc>
		</play>
		<randomFrame public="1" set="method" line="671">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Tell the sprite to change to a random frame of animation
	 * Useful for instantiating particles or other weird things.
	 </haxe_doc>
		</randomFrame>
		<getFrame public="1" set="method" line="682">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Tell the sprite to change to a specific frame of animation.
	 * 
	 * @param	Frame	The frame you want to display.
	 </haxe_doc>
		</getFrame>
		<setFrame public="1" set="method" line="689">
			<f a="Frame">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setFrame>
		<getPixels public="1" set="method" line="700">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>pixels</code> to any <code>BitmapData</code> object.
	 * Automatically adjust graphic size and render helpers.
	 ]]></haxe_doc>
		</getPixels>
		<setPixels public="1" set="method" line="707">
			<f a="Pixels">
				<c path="flash.display.BitmapData"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setPixels>
		<unsafeBind public="1" set="method" line="721">
			<f a="Pixels">
				<c path="flash.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Internal function, currently only used to quickly update HxlState.screen for post-processing.
	 * Potentially super-unsafe, since it doesn't call <code>resetHelpers()</code>!
	 * 
	 * @param	Pixels		The <code>BitmapData</code> object you want to point at.
	 ]]></haxe_doc>
		</unsafeBind>
		<new public="1" set="method" line="108"><f a="?X:?Y:?SimpleGraphic">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Class"><c path="flash.display.Bitmap"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxel.HxlFlash" params="" file="../haxel/HxlFlash.hx">
		<extends path="haxel.HxlSprite"/>
		<_delay>
			<c path="Float"/>
			<haxe_doc>
	 * How long the effect should last.
	 </haxe_doc>
		</_delay>
		<_complete>
			<d/>
			<haxe_doc>
	 * Callback for when the effect is finished.
	 </haxe_doc>
		</_complete>
		<start public="1" set="method" line="41">
			<f a="?Color:?Duration:?FlashComplete:?Force">
				<c path="Int"/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Reset and trigger this special effect
	 * 
	 * @param	Color			The color you want to use
	 * @param	Duration		How long it takes for the flash to fade
	 * @param	FlashComplete	A function you want to run when the flash finishes
	 * @param	Force			Force the effect to reset
	 </haxe_doc>
		</start>
		<stop public="1" set="method" line="54">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Stops and hides this screen effect.
	 </haxe_doc>
		</stop>
		<update public="1" set="method" line="61" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates and/or animates this special effect
	 </haxe_doc>
		</update>
		<new public="1" set="method" line="23">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor for this special effect
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a special effects utility class to help HxlGame do the 'flash' effect
 </haxe_doc>
	</class>
	<class path="flash.system.System" params="" file="C:\Motion-Twin\haxe/std/flash9/system/System.hx" extern="1">
		<freeMemory public="1" static="1"><c path="Float"/></freeMemory>
		<ime public="1" set="null" static="1"><c path="flash.system.IME"/></ime>
		<privateMemory public="1" static="1"><c path="Float"/></privateMemory>
		<totalMemory public="1" set="null" static="1"><t path="UInt"/></totalMemory>
		<totalMemoryNumber public="1" static="1"><c path="Float"/></totalMemoryNumber>
		<useCodePage public="1" static="1"><e path="Bool"/></useCodePage>
		<vmVersion public="1" set="null" static="1"><c path="String"/></vmVersion>
		<disposeXML public="1" static="1"><f a="node">
	<c path="flash.xml.XML"/>
	<e path="Void"/>
</f></disposeXML>
		<exit public="1" set="method" static="1"><f a="code">
	<t path="UInt"/>
	<e path="Void"/>
</f></exit>
		<gc public="1" set="method" static="1"><f a=""><e path="Void"/></f></gc>
		<nativeConstructionOnly public="1" static="1"><f a="object">
	<d/>
	<e path="Void"/>
</f></nativeConstructionOnly>
		<pause public="1" set="method" static="1"><f a=""><e path="Void"/></f></pause>
		<resume public="1" set="method" static="1"><f a=""><e path="Void"/></f></resume>
		<setClipboard public="1" set="method" static="1"><f a="string">
	<c path="String"/>
	<e path="Void"/>
</f></setClipboard>
	</class>
	<class path="flash.display.Shape" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxel.HxlGraphics" params="" file="../haxel/HxlGraphics.hx">
		<_game static="1">
			<c path="haxel.HxlGame"/>
			<haxe_doc>
	 * Reference to the current HxlGame object.
	 </haxe_doc>
		</_game>
		<LIBRARY_NAME public="1" line="26" static="1">
			<c path="String"/>
			<haxe_doc>
	 * If you build and maintain your own version of flixel,
	 * you can give it your own name here.  Appears in the console.
	 </haxe_doc>
		</LIBRARY_NAME>
		<LIBRARY_MAJOR_VERSION public="1" line="31" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Assign a major version to your library.
	 * Appears before the decimal in the console.
	 </haxe_doc>
		</LIBRARY_MAJOR_VERSION>
		<LIBRARY_MINOR_VERSION public="1" line="36" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Assign a minor version to your library.
	 * Appears after the decimal in the console.
	 </haxe_doc>
		</LIBRARY_MINOR_VERSION>
		<_pause static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Internal tracker for game pause state.
	 </haxe_doc>
		</_pause>
		<debug public="1" static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether you are running in Debug or Release mode.
	 </haxe_doc>
		</debug>
		<width public="1" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Width of the screen in game pixels.
	 </haxe_doc>
		</width>
		<height public="1" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Height of the screen in game pixels.
	 </haxe_doc>
		</height>
		<levels public="1" static="1">
			<c path="Array"><d/></c>
			<haxe_doc><![CDATA[
	 * <code>HxlGraphics.levels</code> and <code>HxlGraphics.scores</code> are generic
	 * global variables that can be used for various cross-state stuff.
	 ]]></haxe_doc>
		</levels>
		<level public="1" static="1"><c path="Int"/></level>
		<scores public="1" static="1"><c path="Array"><d/></c></scores>
		<score public="1" static="1"><c path="Int"/></score>
		<saves public="1" static="1">
			<c path="Array"><d/></c>
			<haxe_doc><![CDATA[
	 * <code>HxlGraphics.saves</code> is a generic bucket for storing
	 * FlxSaves so you can access them whenever you want.
	 ]]></haxe_doc>
		</saves>
		<save public="1" static="1"><c path="Int"/></save>
		<buffer public="1" static="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>
	 * References the active graphics buffer.
	 </haxe_doc>
		</buffer>
		<_cache static="1">
			<d/>
			<haxe_doc>
	 * Internal storage system to prevent graphics from being used repeatedly in memory.
	 </haxe_doc>
		</_cache>
		<followTarget public="1" static="1">
			<c path="haxel.HxlObject"/>
			<haxe_doc><![CDATA[
	 * Tells the camera to follow this <code>FlxCore</code> object around.
	 ]]></haxe_doc>
		</followTarget>
		<followLead public="1" static="1">
			<c path="flash.geom.Point"/>
			<haxe_doc><![CDATA[
	 * Used to force the camera to look ahead of the <code>followTarget</code>.
	 ]]></haxe_doc>
		</followLead>
		<followLerp public="1" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Used to smoothly track the camera as it follows.
	 </haxe_doc>
		</followLerp>
		<followMin public="1" static="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * Stores the top and left edges of the camera area.
	 </haxe_doc>
		</followMin>
		<followMax public="1" static="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * Stores the bottom and right edges of the camera area.
	 </haxe_doc>
		</followMax>
		<_scrollTarget static="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * Internal, used to assist camera and scrolling.
	 </haxe_doc>
		</_scrollTarget>
		<scroll public="1" static="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>
	 * Stores the basic parallax scrolling values.
	 </haxe_doc>
		</scroll>
		<_showBounds static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Internal tracker for bounding box visibility.
	 </haxe_doc>
		</_showBounds>
		<elapsed public="1" static="1">
			<c path="Float"/>
			<haxe_doc>
	* Represents the amount of time in seconds that passed since last frame.
	</haxe_doc>
		</elapsed>
		<maxElapsed public="1" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Essentially locks the framerate to a minimum value - any slower and you'll get slowdown instead of frameskip; default is 1/30th of a second.
	 </haxe_doc>
		</maxElapsed>
		<timeScale public="1" static="1">
			<c path="Float"/>
			<haxe_doc>
	 * How fast or slow time should pass in the game; default is 1.0.
	 </haxe_doc>
		</timeScale>
		<numRenders public="1" line="130" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Number of renders made for the current frame.
	 </haxe_doc>
		</numRenders>
		<music public="1" static="1">
			<c path="haxel.HxlSound"/>
			<haxe_doc>
	 * A handy container for a background music object.
	 </haxe_doc>
		</music>
		<sounds public="1" static="1">
			<c path="Array"><c path="haxel.HxlSound"/></c>
			<haxe_doc>
	 * A list of all the sounds being played in the game.
	 </haxe_doc>
		</sounds>
		<_mute static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Internal flag for whether or not the game is muted.
	 </haxe_doc>
		</_mute>
		<_volume static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Internal volume level, used for global sound control.
	 </haxe_doc>
		</_volume>
		<mouse public="1" static="1">
			<c path="haxel.HxlMouse"/>
			<haxe_doc><![CDATA[
	 * A reference to a <code>HxlMouse</code> object.  Important for input!
	 ]]></haxe_doc>
		</mouse>
		<keys public="1" static="1">
			<c path="haxel.HxlKeyboard"/>
			<haxe_doc><![CDATA[
	 * A reference to a <code>HxlKeyboard</code> object.  Important for input!
	 ]]></haxe_doc>
		</keys>
		<flash public="1" static="1">
			<c path="haxel.HxlFlash"/>
			<haxe_doc>
	 * A special effect that flashes a color on the screen.  Usage: HxlGraphics.flash.start();
	 </haxe_doc>
		</flash>
		<quake public="1" static="1">
			<c path="haxel.HxlQuake"/>
			<haxe_doc>
	 * A special effect that shakes the screen.  Usage: HxlGraphics.quake.start();
	 </haxe_doc>
		</quake>
		<fade public="1" static="1">
			<c path="haxel.HxlFade"/>
			<haxe_doc>
	 * A special effect that fades a color onto the screen.  Usage: HxlGraphics.fade.start();
	 </haxe_doc>
		</fade>
		<autoVisible public="1" line="172" static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If set to true, objects which are not currently on screen will skip rendering.
	 </haxe_doc>
		</autoVisible>
		<autoZSort public="1" line="178" static="1">
			<e path="Bool"/>
			<haxe_doc>
	 * If set to true, whenever an object is added to or removed from an HxlGroup, that group
	 * will sort its members according to zIndex, lowest to highest.
	 </haxe_doc>
		</autoZSort>
		<defaultFont public="1" line="180" static="1"><c path="String"/></defaultFont>
		<framerate public="1" get="getFramerate" set="setFramerate" static="1"><c path="Int"/></framerate>
		<frameratePaused public="1" get="getFrameratePaused" set="setFrameratePaused" static="1"><c path="Int"/></frameratePaused>
		<stage public="1" get="getStage" set="null" static="1"><c path="flash.display.Stage"/></stage>
		<showBounds public="1" get="getShowBounds" set="setShowBounds" static="1"><e path="Bool"/></showBounds>
		<mute public="1" get="getMute" set="setMute" static="1"><e path="Bool"/></mute>
		<volume public="1" get="getVolume" set="setVolume" static="1"><c path="Float"/></volume>
		<state public="1" get="getState" set="setState" static="1"><c path="haxel.HxlState"/></state>
		<pause public="1" get="getPause" set="setPause" static="1"><e path="Bool"/></pause>
		<setGameData public="1" set="method" line="196" static="1">
			<f a="Game:Width:Height:Zoom">
				<c path="haxel.HxlGame"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called by HxlGame to set up HxlGraphics during game constructor.
	 </haxe_doc>
		</setGameData>
		<log public="1" set="method" line="226" static="1">
			<f a="Data">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Log data to the developer console.
	 * 
	 * @param	Data		Anything you want to log to the console.
	 </haxe_doc>
		</log>
		<unfollow public="1" set="method" line="235" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Stops and resets the camera.
	 </haxe_doc>
		</unfollow>
		<follow public="1" set="method" line="260" static="1">
			<f a="Target:?Lerp">
				<c path="haxel.HxlObject"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Tells the camera subsystem what <code>HxlCore</code> object to follow.
	 * 
	 * @param	Target		The object to follow.
	 * @param	Lerp		How much lag the camera should have (can help smooth out the camera movement).
	 ]]></haxe_doc>
		</follow>
		<followAdjust public="1" set="method" line="277" static="1">
			<f a="?LeadX:?LeadY">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Specify an additional camera component - the velocity-based "lead",
	 * or amount the camera should track in front of a sprite.
	 * 
	 * @param	LeadX		Percentage of X velocity to add to the camera's motion.
	 * @param	LeadY		Percentage of Y velocity to add to the camera's motion.
	 </haxe_doc>
		</followAdjust>
		<followBounds public="1" set="method" line="290" static="1">
			<f a="?MinX:?MinY:?MaxX:?MaxY:?UpdateWorldBounds">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Specify the boundaries of the level or where the camera is allowed to move.
	 * 
	 * @param	MinX				The smallest X value of your level (usually 0).
	 * @param	MinY				The smallest Y value of your level (usually 0).
	 * @param	MaxX				The largest X value of your level (usually the level width).
	 * @param	MaxY				The largest Y value of your level (usually the level height).
	 * @param	UpdateWorldBounds	Whether the quad tree's dimensions should be updated to match.
	 </haxe_doc>
		</followBounds>
		<makeEven set="method" line="308" static="1">
			<f a="val">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * Used to counter the flickering of dithered surfaced when scrolling
	 </haxe_doc>
		</makeEven>
		<doFollow public="1" set="method" line="319" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that updates the camera and parallax scrolling.
	 </haxe_doc>
		</doFollow>
		<resetInput public="1" set="method" line="354" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Reset the input helper objects (useful when changing screens or states)
	 </haxe_doc>
		</resetInput>
		<checkBitmapCache public="1" set="method" line="366" static="1">
			<f a="Key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Check the local bitmap cache to see if a bitmap with this key has been loaded already.
	 *
	 * @param	Key		The string key identifying the bitmap.
	 * 
	 * @return	Whether or not this file can be found in the cache.
	 </haxe_doc>
		</checkBitmapCache>
		<createBitmap public="1" set="method" line="379" static="1">
			<f a="Width:Height:Color:?Unique:?Key">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[
	 * Generates a new <code>BitmapData</code> object (a colored square) and caches it.
	 * 
	 * @param	Width	How wide the square should be.
	 * @param	Height	How high the square should be.
	 * @param	Color	What color the square should be (0xAARRGGBB)
	 * 
	 * @return	The <code>BitmapData</code> we just created.
	 ]]></haxe_doc>
		</createBitmap>
		<addBitmap public="1" set="method" line="407" static="1">
			<f a="Graphic:?Reverse:?Unique:?Key">
				<c path="Class"><c path="flash.display.Bitmap"/></c>
				<e path="Bool"/>
				<e path="Bool"/>
				<c path="String"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[
	 * Loads a bitmap from a file, caches it, and generates a horizontally flipped version if necessary.
	 * 
	 * @param	Graphic		The image file that you want to load.
	 * @param	Reverse		Whether to generate a flipped version.
	 * 
	 * @return	The <code>BitmapData</code> we just created.
	 ]]></haxe_doc>
		</addBitmap>
		<getStage public="1" set="method" line="454" static="1">
			<f a=""><c path="flash.display.Stage"/></f>
			<haxe_doc><![CDATA[
	 * Retrieves the Flash stage object (required for event listeners)
	 * 
	 * @return	A Flash <code>MovieClip</code> object.
	 ]]></haxe_doc>
		</getStage>
		<getFramerate public="1" set="method" line="466" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * The game and SWF framerate; default is 60.
	 </haxe_doc>
		</getFramerate>
		<setFramerate public="1" set="method" line="473" static="1">
			<f a="Framerate">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setFramerate>
		<getFrameratePaused public="1" set="method" line="484" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * The game and SWF framerate while paused; default is 10.
	 </haxe_doc>
		</getFrameratePaused>
		<setFrameratePaused public="1" set="method" line="491" static="1">
			<f a="Framerate">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setFrameratePaused>
		<getShowBounds public="1" set="method" line="503" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>showBounds</code> to true to display the bounding boxes of the in-game objects.
	 ]]></haxe_doc>
		</getShowBounds>
		<setShowBounds public="1" set="method" line="510" static="1">
			<f a="ShowBounds">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setShowBounds>
		<playMusic public="1" set="method" line="525" static="1">
			<f a="Music:?Volume">
				<c path="Class"><c path="flash.media.Sound"/></c>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Set up and play a looping background soundtrack.
	 * 
	 * @param	Music		The sound file you want to loop in the background.
	 * @param	Volume		How loud the sound should be, from 0 to 1.
	 </haxe_doc>
		</playMusic>
		<play public="1" set="method" line="546" static="1">
			<f a="EmbeddedSound:?Volume:?Looped">
				<c path="Class"><c path="flash.media.Sound"/></c>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="haxel.HxlSound"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a new sound object from an embedded <code>Class</code> object.
	 * 
	 * @param	EmbeddedSound	The sound you want to play.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether or not to loop this sound.
	 * 
	 * @return	A <code>HxlSound</code> object.
	 ]]></haxe_doc>
		</play>
		<stream public="1" set="method" line="574" static="1">
			<f a="URL:?Volume:?Looped">
				<c path="String"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="haxel.HxlSound"/>
			</f>
			<haxe_doc>
	 * Creates a new sound object from a URL.
	 * 
	 * @param	EmbeddedSound	The sound you want to play.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether or not to loop this sound.
	 * 
	 * @return	A HxlSound object.
	 </haxe_doc>
		</stream>
		<getMute public="1" set="method" line="598" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>mute</code> to true to turn off the sound.
	 * 
	 * @default false
	 ]]></haxe_doc>
		</getMute>
		<setMute public="1" set="method" line="605" static="1">
			<f a="Mute">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setMute>
		<getMuteValue public="1" set="method" line="616" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * Get a number that represents the mute state that we can multiply into a sound transform.
	 * 
	 * @return		An unsigned integer - 0 if muted, 1 if not muted.
	 </haxe_doc>
		</getMuteValue>
		<getVolume public="1" set="method" line="629" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>volume</code> to a number between 0 and 1 to change the global volume.
	 * 
	 * @default 0.5
	 ]]></haxe_doc>
		</getVolume>
		<setVolume public="1" set="method" line="634" static="1">
			<f a="Volume">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setVolume>
		<destroySounds public="1" set="method" line="650" static="1">
			<f a="?ForceDestroy">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Called by HxlGame on state changes to stop and destroy sounds.
	 * 
	 * @param	ForceDestroy		Kill sounds even if they're flagged <code>survive</code>.
	 ]]></haxe_doc>
		</destroySounds>
		<changeSounds set="method" line="670" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * An internal function that adjust the volume levels and the music channel after a change.
	 </haxe_doc>
		</changeSounds>
		<updateSounds public="1" set="method" line="687" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Called by the game loop to make sure the sounds get updated each frame.
	 </haxe_doc>
		</updateSounds>
		<pauseSounds set="method" line="705" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal helper, pauses all game sounds.
	 </haxe_doc>
		</pauseSounds>
		<playSounds set="method" line="722" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal helper, pauses all game sounds.
	 </haxe_doc>
		</playSounds>
		<updateInput public="1" set="method" line="739" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Calls update on the keyboard and mouse input tracking objects.
	 </haxe_doc>
		</updateInput>
		<getState public="1" set="method" line="747" static="1">
			<f a=""><c path="haxel.HxlState"/></f>
			<haxe_doc>
	 * Safely access the current game state.
	 </haxe_doc>
		</getState>
		<setState public="1" set="method" line="751" static="1"><f a="State">
	<c path="haxel.HxlState"/>
	<c path="haxel.HxlState"/>
</f></setState>
		<getPause public="1" set="method" line="758" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>pause</code> to true to pause the game, all sounds, and display the pause popup.
	 ]]></haxe_doc>
		</getPause>
		<setPause public="1" set="method" line="765" static="1">
			<f a="Pause">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setPause>
		<new public="1" set="method" line="182"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="86" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="90" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="111" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="128" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="149" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="162" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="174" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="180" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="197" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="201" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="208" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="212" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="244" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="261" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="265" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="269" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<len public="1"><c path="Float"/></len>
		<offset public="1"><c path="Float"/></offset>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<start public="1"><c path="Float"/></start>
		<streamName public="1"><c path="String"/></streamName>
		<transition public="1"><e path="flash.net.NetStreamPlayTransitions"/></transition>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxel.HxlMenu" params="" file="../haxel/HxlMenu.hx">
		<extends path="haxel.HxlDialog"/>
		<scrollSound public="1" get="getScrollSound" set="setScrollSound"><c path="haxel.HxlSound"/></scrollSound>
		<selectSound public="1" get="getSelectSound" set="setSelectSound"><c path="haxel.HxlSound"/></selectSound>
		<background><c path="haxel.HxlSprite"/></background>
		<items><c path="Array"><c path="haxel.HxlMenuItem"/></c></items>
		<_scrollSound><c path="haxel.HxlSound"/></_scrollSound>
		<_selectSound><c path="haxel.HxlSound"/></_selectSound>
		<inputEnabled><e path="Bool"/></inputEnabled>
		<currentItem><c path="Int"/></currentItem>
		<addItem public="1" set="method" line="32"><f a="Item">
	<c path="haxel.HxlMenuItem"/>
	<e path="Void"/>
</f></addItem>
		<toggleInput public="1" set="method" line="42"><f a="Toggle">
	<e path="Bool"/>
	<e path="Void"/>
</f></toggleInput>
		<onKeyDown set="method" line="53"><f a="event">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<onMouseUp set="method" line="70"><f a="event">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<setBackgroundColor public="1" set="method" line="76"><f a="Color">
	<c path="Int"/>
	<e path="Void"/>
</f></setBackgroundColor>
		<setBackgroundGraphic public="1" set="method" line="80"><f a="Graphic">
	<c path="Class"><c path="flash.display.Bitmap"/></c>
	<e path="Void"/>
</f></setBackgroundGraphic>
		<getScrollSound public="1" set="method" line="84"><f a=""><c path="haxel.HxlSound"/></f></getScrollSound>
		<setScrollSound public="1" set="method" line="88"><f a="ScrollSound">
	<c path="haxel.HxlSound"/>
	<c path="haxel.HxlSound"/>
</f></setScrollSound>
		<getSelectSound public="1" set="method" line="93"><f a=""><c path="haxel.HxlSound"/></f></getSelectSound>
		<setSelectSound public="1" set="method" line="97"><f a="SelectSound">
	<c path="haxel.HxlSound"/>
	<c path="haxel.HxlSound"/>
</f></setSelectSound>
		<update public="1" set="method" line="102" override="1"><f a=""><e path="Void"/></f></update>
		<destroy public="1" set="method" line="107" override="1"><f a=""><e path="Void"/></f></destroy>
		<new public="1" set="method" line="20"><f a="?X:?Y:?Width:?Height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
	</enum>
	<class path="flash.errors.Error" params="" file="C:\Motion-Twin\haxe/std/flash9/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.display.Stage" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<color public="1"><t path="UInt"/></color>
		<colorCorrection public="1"><e path="flash.display.ColorCorrection"/></colorCorrection>
		<colorCorrectionSupport public="1" set="null"><e path="flash.display.ColorCorrectionSupport"/></colorCorrectionSupport>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><c path="Float"/></frameRate>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageVideos public="1"><c path="flash.Vector"><c path="flash.media.StageVideo"/></c></stageVideos>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<wmodeGPU public="1"><e path="Bool"/></wmodeGPU>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
	</class>
	<class path="haxel.HxlState" params="" file="../haxel/HxlState.hx">
		<extends path="flash.display.Sprite"/>
		<screen public="1" static="1"><c path="haxel.HxlSprite"/></screen>
		<bgColor public="1" static="1"><c path="Int"/></bgColor>
		<defaultGroup public="1"><c path="haxel.HxlGroup"/></defaultGroup>
		<create public="1" set="method" line="27"><f a=""><e path="Void"/></f></create>
		<add public="1" set="method" line="30"><f a="obj">
	<c path="haxel.HxlObject"/>
	<c path="haxel.HxlObject"/>
</f></add>
		<remove public="1" set="method" line="34"><f a="obj">
	<c path="haxel.HxlObject"/>
	<c path="haxel.HxlObject"/>
</f></remove>
		<preProcess public="1" set="method" line="38"><f a=""><e path="Void"/></f></preProcess>
		<render public="1" set="method" line="43"><f a=""><e path="Void"/></f></render>
		<postProcess public="1" set="method" line="47"><f a=""><e path="Void"/></f></postProcess>
		<update public="1" set="method" line="50"><f a=""><e path="Void"/></f></update>
		<destroy public="1" set="method" line="54"><f a=""><e path="Void"/></f></destroy>
		<new public="1" set="method" line="12"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="StateTest" params="" file="StateTest.hx">
		<extends path="haxel.HxlState"/>
		<create public="1" set="method" line="16" override="1"><f a=""><e path="Void"/></f></create>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" get="inline" set="null" line="40" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="44" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="57" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="61" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="67" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="71" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="86" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="92" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="99" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<enum path="flash.net.NetStreamPlayTransitions" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamPlayTransitions.hx">
		<SWITCH/>
		<SWAP/>
		<STOP/>
		<RESET/>
		<APPEND/>
	</enum>
	<class path="flash.filters.BlurFilter" params="" file="C:\Motion-Twin\haxe/std/flash9/filters/BlurFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<blurX public="1"><c path="Float"/></blurX>
		<blurY public="1"><c path="Float"/></blurY>
		<quality public="1"><c path="Int"/></quality>
		<new public="1" set="method"><f a="?blurX:?blurY:?quality">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.FontType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
	</enum>
	<class path="flash.net.NetStream" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1"><c path="String"/></CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1"><c path="String"/></DIRECT_CONNECTIONS>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<audioReliable public="1"><e path="Bool"/></audioReliable>
		<audioSampleAccess public="1"><e path="Bool"/></audioSampleAccess>
		<backBufferLength public="1"><c path="Float"/></backBufferLength>
		<backBufferTime public="1"><c path="Float"/></backBufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferTimeMax public="1"><c path="Float"/></bufferTimeMax>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<client public="1"><d/></client>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<dataReliable public="1"><e path="Bool"/></dataReliable>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<farID public="1" set="null"><c path="String"/></farID>
		<farNonce public="1" set="null"><c path="String"/></farNonce>
		<inBufferSeek public="1"><e path="Bool"/></inBufferSeek>
		<info public="1" set="null"><c path="flash.net.NetStreamInfo"/></info>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<maxPauseBufferTime public="1"><c path="Float"/></maxPauseBufferTime>
		<multicastAvailabilitySendToAll public="1"><e path="Bool"/></multicastAvailabilitySendToAll>
		<multicastAvailabilityUpdatePeriod public="1"><c path="Float"/></multicastAvailabilityUpdatePeriod>
		<multicastFetchPeriod public="1"><c path="Float"/></multicastFetchPeriod>
		<multicastInfo public="1"><c path="flash.net.NetStreamMulticastInfo"/></multicastInfo>
		<multicastPushNeighborLimit public="1"><c path="Float"/></multicastPushNeighborLimit>
		<multicastRelayMarginDuration public="1"><c path="Float"/></multicastRelayMarginDuration>
		<multicastWindowDuration public="1"><c path="Float"/></multicastWindowDuration>
		<nearNonce public="1" set="null"><c path="String"/></nearNonce>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<peerStreams public="1" set="null"><c path="Array"><d/></c></peerStreams>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<time public="1" set="null"><c path="Float"/></time>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<videoReliable public="1"><e path="Bool"/></videoReliable>
		<videoSampleAccess public="1"><e path="Bool"/></videoSampleAccess>
		<appendBytes public="1"><f a="bytes">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></appendBytes>
		<appendBytesAction public="1"><f a="netStreamAppendBytesAction">
	<e path="flash.net.NetStreamAppendBytesAction"/>
	<e path="Void"/>
</f></appendBytesAction>
		<attach public="1"><f a="connection">
	<c path="flash.net.NetConnection"/>
	<e path="Void"/>
</f></attach>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<onPeerConnect public="1" set="method"><f a="subscriber">
	<c path="flash.net.NetStream"/>
	<e path="Bool"/>
</f></onPeerConnect>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<play2 public="1" set="method"><f a="param">
	<c path="flash.net.NetStreamPlayOptions"/>
	<e path="Void"/>
</f></play2>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<step public="1"><f a="frames">
	<c path="Int"/>
	<e path="Void"/>
</f></step>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxel.HxlUtil" params="" file="../haxel/HxlUtil.hx">
		<roundingError public="1" line="12" static="1"><c path="Float"/></roundingError>
		<quadTree public="1" static="1">
			<c path="haxel.HxlQuadTree"/>
			<haxe_doc>
	 * The global quad tree (stored here since it is used primarily by HxlUtil functions).
	 * Set this to null to force it to refresh on the next collide.
	 </haxe_doc>
		</quadTree>
		<quadTreeBounds public="1" static="1">
			<c path="haxel.HxlRect"/>
			<haxe_doc>
	 * This variable stores the dimensions of the root of the quad tree.
	 * This is the eligible game collision space.
	 </haxe_doc>
		</quadTreeBounds>
		<quadTreeDivisions public="1" line="27" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Controls the granularity of the quad tree.  Default is 3 (decent performance on large and small worlds).
	 </haxe_doc>
		</quadTreeDivisions>
		<_seed static="1">
			<c path="Float"/>
			<haxe_doc>
	 * Internal random number calculation helpers.
	 </haxe_doc>
		</_seed>
		<colorRGB public="1" set="method" line="34" static="1"><f a="Color">
	<c path="Int"/>
	<c path="Array"><c path="Int"/></c>
</f></colorRGB>
		<colorInt public="1" set="method" line="42" static="1"><f a="Red:Green:Blue">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></colorInt>
		<floor public="1" set="method" line="46" static="1"><f a="N">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" line="51" static="1"><f a="N">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<random public="1" set="method" line="63" static="1">
			<f a="?UseGlobalSeed">
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Generate a pseudo-random number.
	 * 
	 * @param	UseGlobalSeed		Whether or not to use the stored HxlUtil.seed value to calculate it.
	 * 
	 * @return	A pseudo-random Number object.
	 </haxe_doc>
		</random>
		<randomize public="1" set="method" line="80" static="1">
			<f a="Seed">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * Generate a pseudo-random number.
	 * 
	 * @param	Seed		The number to use to generate a new random value.
	 * 
	 * @return	A pseudo-random Number object.
	 </haxe_doc>
		</randomize>
		<mutate public="1" set="method" line="92" static="1">
			<f a="Seed:Mutator">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc><![CDATA[
	 * Mutates a seed or other number, useful when combined with <code>randomize()</code>.
	 * 
	 * @param	Seed		The number to mutate.
	 * @param	Mutator		The value to use in the mutation.
	 * 
	 * @return	A predictably-altered version of the Seed.
	 ]]></haxe_doc>
		</mutate>
		<setWorldBounds public="1" set="method" line="111" static="1">
			<f a="?X:?Y:?Width:?Height:?Divisions">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Call this function to specify a more efficient boundary for your game world.
	 * This boundary is used by <code>overlap()</code> and <code>collide()</code>, so it
	 * can't hurt to have it be the right size!  Flixel will invent a size for you, but
	 * it's pretty huge - 256x the size of the screen, whatever that may be.
	 * Leave width and height empty if you want to just update the game world's position.
	 * 
	 * @param	X			The X-coordinate of the left side of the game world.
	 * @param	Y			The Y-coordinate of the top of the game world.
	 * @param	Width		Desired width of the game world.
	 * @param	Height		Desired height of the game world.
	 * @param	Divisions	Pass a non-zero value to set <code>quadTreeDivisions</code>.  Default value is 3.
	 ]]></haxe_doc>
		</setWorldBounds>
		<overlap public="1" set="method" line="140" static="1">
			<f a="Object1:Object2:?Callback">
				<c path="haxel.HxlObject"/>
				<c path="haxel.HxlObject"/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Call this function to see if one <code>HxlObject</code> overlaps another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat!  It will put everything into a quad tree and then
	 * check for overlaps.  For maximum performance try bundling a lot of objects
	 * together using a <code>HxlGroup</code> (even bundling groups together!)
	 * NOTE: does NOT take objects' scrollfactor into account.
	 * 
	 * @param	Object1		The first object or group you want to check.
	 * @param	Object2		The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	Callback	A function with two <code>HxlObject</code> parameters - e.g. <code>myOverlapFunction(Object1:HxlObject,Object2:HxlObject);</code>  If no function is provided, <code>HxlQuadTree</code> will call <code>kill()</code> on both objects.
	 ]]></haxe_doc>
		</overlap>
		<computeVelocity public="1" set="method" line="164" static="1">
			<f a="Velocity:?Acceleration:?Drag:?Max">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * A tween-like function that takes a starting velocity
	 * and some other factors and returns an altered velocity.
	 * 
	 * @param	Velocity		Any component of velocity (e.g. 20).
	 * @param	Acceleration	Rate at which the velocity is changing.
	 * @param	Drag			Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.
	 * @param	Max				An absolute value cap for the velocity.
	 * 
	 * @return	The altered Velocity value.
	 </haxe_doc>
		</computeVelocity>
		<rotatePoint public="1" set="method" line="199" static="1">
			<f a="X:Y:PivotX:PivotY:Angle:?P">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="haxel.HxlPoint"/>
				<c path="haxel.HxlPoint"/>
			</f>
			<haxe_doc><![CDATA[
	 * Rotates a point in 2D space around another point by the given angle.
	 * 
	 * @param	X		The X coordinate of the point you want to rotate.
	 * @param	Y		The Y coordinate of the point you want to rotate.
	 * @param	PivotX	The X coordinate of the point you want to rotate around.
	 * @param	PivotY	The Y coordinate of the point you want to rotate around.
	 * @param	Angle	Rotate the point by this many degrees.
	 * @param	P		Optional <code>HxlPoint</code> to store the results in.
	 * 
	 * @return	A <code>HxlPoint</code> containing the coordinates of the rotated point.
	 ]]></haxe_doc>
		</rotatePoint>
		<distance public="1" get="inline" set="null" line="209" static="1"><f a="src:dest">
	<c path="haxel.HxlPoint"/>
	<c path="haxel.HxlPoint"/>
	<c path="Float"/>
</f></distance>
		<markFieldOfView public="1" set="method" line="213" static="1"><f a="position:radius:map:?radial">
	<c path="haxel.HxlPoint"/>
	<c path="Float"/>
	<c path="haxel.HxlTilemap"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></markFieldOfView>
		<travrseLine public="1" set="method" line="237" static="1"><f a="src:dest:?isBlocking:apply:?maxDist">
	<c path="haxel.HxlPoint"/>
	<c path="haxel.HxlPoint"/>
	<f a="">
		<c path="haxel.HxlPoint"/>
		<e path="Bool"/>
	</f>
	<f a="">
		<c path="haxel.HxlPoint"/>
		<e path="Void"/>
	</f>
	<c path="Float"/>
	<e path="Void"/>
</f></travrseLine>
		<getLine public="1" set="method" line="244" static="1"><f a="src:dest:?isBlocking">
	<c path="haxel.HxlPoint"/>
	<c path="haxel.HxlPoint"/>
	<f a="">
		<c path="haxel.HxlPoint"/>
		<e path="Bool"/>
	</f>
	<c path="Array"><c path="haxel.HxlPoint"/></c>
</f></getLine>
		<contains public="1" params="T" set="method" line="296" static="1"><f a="array:element">
	<c path="Array"><c path="contains.T"/></c>
	<c path="contains.T"/>
	<e path="Bool"/>
</f></contains>
		<randomInt public="1" set="method" line="303" static="1"><f a="max">
	<c path="Int"/>
	<c path="Int"/>
</f></randomInt>
		<getRandomTile public="1" params="T" set="method" line="307" static="1"><f a="width:height:map:tileTypesToGet">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="Array"><c path="getRandomTile.T"/></c></c>
	<c path="Array"><c path="getRandomTile.T"/></c>
	<c path="haxel.HxlPoint"/>
</f></getRandomTile>
		<cloneMap public="1" params="T" set="method" line="317" static="1"><f a="map">
	<c path="Array"><c path="Array"><c path="cloneMap.T"/></c></c>
	<c path="Array"><c path="Array"><c path="cloneMap.T"/></c></c>
</f></cloneMap>
		<copyMap public="1" params="T" set="method" line="327" static="1"><f a="srcMap:destMap">
	<c path="Array"><c path="Array"><c path="copyMap.T"/></c></c>
	<c path="Array"><c path="Array"><c path="copyMap.T"/></c></c>
	<e path="Void"/>
</f></copyMap>
		<countTiles public="1" set="method" line="333" static="1"><f a="width:height:map:tilesToCount">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="Array"><c path="Int"/></c></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
</f></countTiles>
		<repalceAllTiles public="1" set="method" line="343" static="1"><f a="width:height:map:tileToReplace:replacement">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><c path="Array"><c path="Int"/></c></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></repalceAllTiles>
		<new public="1" set="method" line="10"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="C:\Motion-Twin\haxe/std/flash9/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
	</enum>
	<class path="flash.media.SoundChannel" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.StageDisplayState" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
	</enum>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\Motion-Twin\haxe/std/flash9/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.Namespace" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Namespace.hx" extern="1">
		<prefix public="1" set="null"><d/></prefix>
		<uri public="1" set="null"><c path="String"/></uri>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\Motion-Twin\haxe/std/flash9/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<height public="1" set="null"><c path="Int"/></height>
		<isURLInaccessible public="1"><e path="Bool"/></isURLInaccessible>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><e path="flash.display.SWFVersion"/></swfVersion>
		<uncaughtErrorEvents public="1"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><c path="Int"/></width>
	</class>
	<enum path="flash.display.SWFVersion" params="" file="C:\Motion-Twin\haxe/std/flash9/display/SWFVersion.hx">
		<FLASH9/>
		<FLASH8/>
		<FLASH7/>
		<FLASH6/>
		<FLASH5/>
		<FLASH4/>
		<FLASH3/>
		<FLASH2/>
		<FLASH10/>
		<FLASH1/>
	</enum>
	<class path="flash.display.ShaderData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.LineScaleMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
	</enum>
	<class path="flash.display.Graphics" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginShaderFill public="1" set="method"><f a="shader:?matrix">
	<c path="flash.display.Shader"/>
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></beginShaderFill>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<copyFrom public="1" set="method"><f a="sourceGraphics">
	<c path="flash.display.Graphics"/>
	<e path="Void"/>
</f></copyFrom>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawGraphicsData public="1" set="method"><f a="graphicsData">
	<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
	<e path="Void"/>
</f></drawGraphicsData>
		<drawPath public="1" set="method"><f a="commands:data:?winding">
	<c path="flash.Vector"><c path="Int"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="flash.display.GraphicsPathWinding"/>
	<e path="Void"/>
</f></drawPath>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawTriangles public="1" set="method"><f a="vertices:?indices:?uvtData:?culling">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Int"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="flash.display.TriangleCulling"/>
	<e path="Void"/>
</f></drawTriangles>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<lineBitmapStyle public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></lineBitmapStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineShaderStyle public="1" set="method"><f a="shader:?matrix">
	<c path="flash.display.Shader"/>
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></lineShaderStyle>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.BitmapData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><c path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<width public="1" set="null"><c path="Int"/></width>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getVector public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><t path="UInt"/></c>
</f></getVector>
		<histogram public="1" set="method"><f a="?hRect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
</f></histogram>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setVector public="1" set="method"><f a="rect:inputVector">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.Vector"><t path="UInt"/></c>
	<e path="Void"/>
</f></setVector>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxel.HxlText" params="" file="../haxel/HxlText.hx">
		<extends path="haxel.HxlSprite"/>
		<alignment public="1" get="getAlignment" set="setAlignment"><c path="String"/></alignment>
		<color public="1" get="getColor" set="setColor" override="1"><c path="Int"/></color>
		<font public="1" get="getFont" set="setFont"><c path="String"/></font>
		<shadow public="1" get="getShadow" set="setShadow"><c path="Int"/></shadow>
		<size public="1" get="getSize" set="setSize"><c path="Float"/></size>
		<text public="1" get="getText" set="setText"><c path="String"/></text>
		<_tf><c path="flash.text.TextField"/></_tf>
		<_regen><e path="Bool"/></_regen>
		<_shadow><c path="Int"/></_shadow>
		<setFormat public="1" set="method" line="88">
			<f a="?Font:?Size:?Color:?Alignment:?ShadowColor">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="haxel.HxlText"/>
			</f>
			<haxe_doc>
	 * You can use this if you have a lot of text parameters
	 * to set instead of the individual properties.
	 * 
	 * @param	Font		The name of the font face for the text display.
	 * @param	Size		The size of the font (in pixels essentially).
	 * @param	Color		The color of the text in traditional flash 0xRRGGBB format.
	 * @param	Alignment	A string representing the desired alignment ("left,"right" or "center").
	 * @param	ShadowColor	A Int representing the desired text shadow color in flash 0xRRGGBB format.
	 * 
	 * @return	This HxlText instance (nice for chaining stuff together, if you're into that).
	 </haxe_doc>
		</setFormat>
		<getText public="1" set="method" line="108">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * The text being displayed.
	 </haxe_doc>
		</getText>
		<setText public="1" set="method" line="115">
			<f a="Text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setText>
		<getSize public="1" set="method" line="128">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
	 * The size of the text being displayed.
	 </haxe_doc>
		</getSize>
		<setSize public="1" set="method" line="135">
			<f a="Size">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setSize>
		<getColor public="1" set="method" line="148" override="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	 * The color of the text being displayed.
	 </haxe_doc>
		</getColor>
		<setColor public="1" set="method" line="155" override="1">
			<f a="Color">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setColor>
		<getFont public="1" set="method" line="168">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * The font used for this text.
	 </haxe_doc>
		</getFont>
		<setFont public="1" set="method" line="175">
			<f a="Font">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setFont>
		<getAlignment public="1" set="method" line="188">
			<f a=""><c path="String"/></f>
			<haxe_doc>
	 * The alignment of the font ("left", "right", or "center").
	 </haxe_doc>
		</getAlignment>
		<setAlignment public="1" set="method" line="195">
			<f a="Alignment">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setAlignment>
		<getShadow public="1" set="method" line="204"><f a=""><c path="Int"/></f></getShadow>
		<setShadow public="1" set="method" line="211">
			<f a="Color">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setShadow>
		<calcFrame set="method" line="220" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function to update the current animation frame.
	 </haxe_doc>
		</calcFrame>
		<dtfCopy set="method" line="300">
			<f a=""><c path="flash.text.TextFormat"/></f>
			<haxe_doc><![CDATA[
	 * A helper function for updating the <code>TextField</code> that we use for rendering.
	 * 
	 * @return	A writable copy of <code>TextField.defaultTextFormat</code>.
	 ]]></haxe_doc>
		</dtfCopy>
		<new public="1" set="method" line="42">
			<f a="X:Y:Width:?Text:?EmbeddedFont:?FontName">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Creates a new <code>HxlText</code> object at the specified position.
	 * 
	 * @param	X				The X position of the text.
	 * @param	Y				The Y position of the text.
	 * @param	Width			The width of the text object (height is determined automatically).
	 * @param	Text			The actual text you would like to display initially.
	 * @param	EmbeddedFont	Whether this text field uses embedded fonts or not
	 * @param 	FontName 		Name of the font to use
	 ]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
 * Extends <code>HxlSprite</code> to support rendering text.
 * Can tint, fade, rotate and scale just like a sprite.
 * Doesn't really animate though, as far as I know.
 * Also does nice pixel-perfect centering on pixel fonts
 * as long as they are only one liners.
 ]]></haxe_doc>
	</class>
	<class path="flash.geom.Point" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><c path="Float"/></length>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.StageVideo" params="" file="C:\Motion-Twin\haxe/std/flash9/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<depth public="1"><c path="Int"/></depth>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.system.LoaderContext" params="" file="C:\Motion-Twin\haxe/std/flash9/system/LoaderContext.hx" extern="1">
		<allowCodeImport public="1"><e path="Bool"/></allowCodeImport>
		<allowLoadBytesCodeExecution public="1"><e path="Bool"/></allowLoadBytesCodeExecution>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxel.HxlFade" params="" file="../haxel/HxlFade.hx">
		<extends path="haxel.HxlSprite"/>
		<_delay>
			<c path="Float"/>
			<haxe_doc>
	 * How long the effect should last.
	 </haxe_doc>
		</_delay>
		<_complete>
			<d/>
			<haxe_doc>
	 * Callback for when the effect is finished.
	 </haxe_doc>
		</_complete>
		<_fadeOut>
			<e path="Bool"/>
			<haxe_doc>
	 * If true, fade out. If false, fade in.
	 </haxe_doc>
		</_fadeOut>
		<start public="1" set="method" line="50">
			<f a="?FadeOut:?Color:?Duration:?FadeComplete:?Force">
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Reset and trigger this special effect
	 * 
	 * @param	Color			The color you want to use
	 * @param	Duration		How long it should take to fade the screen out
	 * @param	FadeComplete	A function you want to run when the fade finishes
	 * @param	Force			Force the effect to reset
	 </haxe_doc>
		</start>
		<fadeText public="1" set="method" line="78"><f a="params">
	<d/>
	<e path="Void"/>
</f></fadeText>
		<stop public="1" set="method" line="86">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Stops and hides this screen effect.
	 </haxe_doc>
		</stop>
		<update public="1" set="method" line="93" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates and/or animates this special effect
	 </haxe_doc>
		</update>
		<new public="1" set="method" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor initializes the fade object
	 </haxe_doc>
		</new>
	</class>
	<class path="haxel.HxlGame" params="" file="../haxel/HxlGame.hx">
		<extends path="flash.display.Sprite"/>
		<SndFlixel><c path="Class"><c path="flash.media.Sound"/></c></SndFlixel>
		<SndBeep><c path="Class"><c path="flash.media.Sound"/></c></SndBeep>
		<useDefaultHotKeys public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Sets 0, -, and + to control the global volume and P to pause.
	 * @default true
	 </haxe_doc>
		</useDefaultHotKeys>
		<pause public="1">
			<c path="haxel.HxlGroup"/>
			<haxe_doc><![CDATA[
	 * Displayed whenever the game is paused.
	 * Override with your own <code>HxlLayer</code> for hot custom pause action!
	 * Defaults to <code>data.HxlPause</code>.
	 ]]></haxe_doc>
		</pause>
		<_created public="1"><e path="Bool"/></_created>
		<_iState public="1"><c path="Class"><c path="haxel.HxlState"/></c></_iState>
		<_elapsed public="1"><c path="Float"/></_elapsed>
		<_total public="1"><c path="Int"/></_total>
		<_framerate public="1"><c path="Int"/></_framerate>
		<_frameratePaused public="1"><c path="Int"/></_frameratePaused>
		<_screen public="1"><c path="flash.display.Sprite"/></_screen>
		<_state public="1"><c path="haxel.HxlState"/></_state>
		<_buffer public="1"><c path="flash.display.Bitmap"/></_buffer>
		<_zoom public="1"><c path="Int"/></_zoom>
		<_gameXOffset public="1"><c path="Int"/></_gameXOffset>
		<_gameYOffset public="1"><c path="Int"/></_gameYOffset>
		<_frame public="1"><c path="Class"><c path="flash.display.Bitmap"/></c></_frame>
		<_zeroPoint public="1"><c path="flash.geom.Point"/></_zeroPoint>
		<_paused public="1"><e path="Bool"/></_paused>
		<_autoPause public="1"><e path="Bool"/></_autoPause>
		<_console public="1"><c path="haxel.HxlConsole"/></_console>
		<_soundTray public="1"><c path="flash.display.Sprite"/></_soundTray>
		<_soundTrayTimer public="1"><c path="Float"/></_soundTrayTimer>
		<_soundTrayBars public="1"><c path="Array"><c path="flash.display.Bitmap"/></c></_soundTrayBars>
		<defaultFont public="1"><c path="String"/></defaultFont>
		<showSoundTray public="1" set="method" line="116">
			<f a="?Silent">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Makes the little volume tray slide out.
	 * 
	 * @param	Silent	Whether or not it should beep.
	 </haxe_doc>
		</showSoundTray>
		<switchState public="1" set="method" line="139">
			<f a="State">
				<c path="haxel.HxlState"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Switch from one <code>HxlState</code> to another.
	 * Usually called from <code>HxlGraphics</code>.
	 * 
	 * @param	State		The class name of the state you want (e.g. PlayState)
	 ]]></haxe_doc>
		</switchState>
		<onKeyUp set="method" line="164"><f a="event">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyUp>
		<unpauseGame public="1" set="method" line="203">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function to help with basic pause game functionality.
	 </haxe_doc>
		</unpauseGame>
		<pauseGame public="1" set="method" line="216">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function to help with basic pause game functionality.
	 </haxe_doc>
		</pauseGame>
		<onFocus set="method" line="232">
			<f a="?event">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Internal event handler for input and focus.
	 </haxe_doc>
		</onFocus>
		<onFocusLost set="method" line="241">
			<f a="?event">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Internal event handler for input and focus.
	 </haxe_doc>
		</onFocusLost>
		<create public="1" set="method" line="247"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></create>
		<update public="1" set="method" line="346"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></update>
		<new public="1" set="method" line="85"><f a="GameSizeX:GameSizeY:InitialState:?Zoom:?DefaultFont">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Class"><c path="haxel.HxlState"/></c>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="MainGame" params="" file="MainGame.hx">
		<extends path="haxel.HxlGame"/>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.PerspectiveProjection" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/PerspectiveProjection.hx" extern="1">
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<focalLength public="1"><c path="Float"/></focalLength>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="46">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="57">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="73">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="87">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="haxel.HxlTilemap" params="" file="../haxel/HxlTilemap.hx">
		<extends path="haxel.HxlObject"/>
		<ImgAuto public="1" static="1"><c path="Class"><c path="flash.display.Bitmap"/></c></ImgAuto>
		<ImgAutoAlt public="1" static="1"><c path="Class"><c path="flash.display.Bitmap"/></c></ImgAutoAlt>
		<OFF public="1" line="33" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * No auto-tiling.
	 </haxe_doc>
		</OFF>
		<AUTO public="1" line="37" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Platformer-friendly auto-tiling.
	 </haxe_doc>
		</AUTO>
		<ALT public="1" line="41" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Top-down auto-tiling.
	 </haxe_doc>
		</ALT>
		<arrayToCSV public="1" set="method" line="573" static="1">
			<f a="Data:Width">
				<c path="Array"><c path="Int"/></c>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[
	 * Converts a one-dimensional array of tile data to a comma-separated string.
	 * 
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * 
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.
	 ]]></haxe_doc>
		</arrayToCSV>
		<alpha public="1" get="getAlpha" set="setAlpha"><c path="Float"/></alpha>
		<collideIndex public="1">
			<c path="Int"/>
			<haxe_doc>
	 * What tile index will you start colliding with (default: 1).
	 </haxe_doc>
		</collideIndex>
		<startingIndex public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The first index of your tile sheet (default: 0) If you want to change it, do so before calling loadMap().
	 </haxe_doc>
		</startingIndex>
		<drawIndex public="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[
	 * What tile index will you start drawing with (default: 1)  NOTE: should always be >= startingIndex.
	 * If you want to change it, do so before calling loadMap().
	 ]]></haxe_doc>
		</drawIndex>
		<auto public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Set this flag to use one of the 16-tile binary auto-tile algorithms (OFF, AUTO, or ALT).
	 </haxe_doc>
		</auto>
		<widthInTiles public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Read-only variable, do NOT recommend changing after the map is loaded!
	 </haxe_doc>
		</widthInTiles>
		<heightInTiles public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Read-only variable, do NOT recommend changing after the map is loaded!
	 </haxe_doc>
		</heightInTiles>
		<totalTiles public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Read-only variable, do NOT recommend changing after the map is loaded!
	 </haxe_doc>
		</totalTiles>
		<mapData public="1"><c path="Array"><c path="Array"><c path="Int"/></c></c></mapData>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>
	 * Rendering helper.
	 </haxe_doc>
		</_flashRect>
		<_pixels><c path="flash.display.BitmapData"/></_pixels>
		<_bbPixels><c path="flash.display.BitmapData"/></_bbPixels>
		<_bbKey><c path="String"/></_bbKey>
		<_tileWidth><c path="Int"/></_tileWidth>
		<_tileHeight><c path="Int"/></_tileHeight>
		<_block><c path="haxel.HxlObject"/></_block>
		<_callbacks><c path="Array"><d/></c></_callbacks>
		<_screenRows><c path="Int"/></_screenRows>
		<_screenCols><c path="Int"/></_screenCols>
		<_tiles><c path="Array"><c path="Array"><c path="haxel.HxlTile"/></c></c></_tiles>
		<blend public="1">
			<c path="String"/>
			<haxe_doc>
	 * Blending modes, just like Photoshop!
	 * E.g. "multiply", "screen", etc.
	 * @default null
	 </haxe_doc>
		</blend>
		<_alpha><c path="Float"/></_alpha>
		<_color><c path="Int"/></_color>
		<_ct><c path="flash.geom.ColorTransform"/></_ct>
		<_mtx><c path="flash.geom.Matrix"/></_mtx>
		<tileClass public="1"><c path="Class"><c path="haxel.HxlTile"/></c></tileClass>
		<loadMap public="1" set="method" line="147">
			<f a="MapData:TileGraphic:?TileWidth:?TileHeight:?RowWidth">
				<c path="Array"><c path="Array"><c path="Int"/></c></c>
				<c path="Class"><c path="flash.display.Bitmap"/></c>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="haxel.HxlTilemap"/>
			</f>
			<haxe_doc>
	 * Load the tilemap with string data and a tile graphic.
	 * 
	 * @param	MapData			2d array of Ints, specifies index of sprite to use from TileGraphic.	
	 * @param	TileGraphic		All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param	TileWidth		The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param	TileHeight		The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * 
	 * @return	A pointer this instance of HxlTilemap, for chaining as usual :)
	 </haxe_doc>
		</loadMap>
		<generateBoundingTiles set="method" line="215">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Generates a bounding box version of the tiles, flixel should call this automatically when necessary.
	 </haxe_doc>
		</generateBoundingTiles>
		<renderTilemap set="method" line="302">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that actually renders the tilemap.  Called by render().
	 </haxe_doc>
		</renderTilemap>
		<render public="1" set="method" line="362" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Draws the tilemap.
	 </haxe_doc>
		</render>
		<getTile public="1" set="method" line="374">
			<f a="X:Y">
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc>
	 * Returns the tile which exists at the specified coordinate.
	 *
	 * @param	X		X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		Y coordinate of the tile (in tiles, not pixels).
	 *
	 * @return HxlTile object
	 </haxe_doc>
		</getTile>
		<getTilePos public="1" set="method" line="389">
			<f a="X:Y:?Center">
				<d/>
				<d/>
				<e path="Bool"/>
				<c path="haxel.HxlPoint"/>
			</f>
			<haxe_doc>
	 * Returns an HxlPoint containing the world position of a tile.
	 * 
	 * @param	X		X coordinate of target tile (in tiles, not pixels).
	 * @param	Y		Y coordinate of target tile (in tiles, not pixels).
	 * @param	Center	If true, returns point centered on tile.
	 * @return HxlPoint object
	 </haxe_doc>
		</getTilePos>
		<follow public="1" set="method" line="472">
			<f a="?Border">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Call this function to lock the automatic camera to the map's edges.
	 * 
	 * @param	Border		Adjusts the camera follow boundary by whatever number of tiles you specify here.  Handy for blocking off deadends that are offscreen, etc.  Use a negative number to add padding instead of hiding the edges.
	 </haxe_doc>
		</follow>
		<ray public="1" set="method" line="488">
			<f a="StartX:StartY:EndX:EndY:Result:?Resolution">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="haxel.HxlPoint"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * Shoots a ray from the start point to the end point.
	 * If/when it passes through a tile, it stores and returns that point.
	 * 
	 * @param	StartX		The X component of the ray's start.
	 * @param	StartY		The Y component of the ray's start.
	 * @param	EndX		The X component of the ray's end.
	 * @param	EndY		The Y component of the ray's end.
	 * @param	Result		A <code>Point</code> object containing the first wall impact.
	 * @param	Resolution	Defaults to 1, meaning check every tile or so.  Higher means more checks!
	 * @return	Whether or not there was a collision between the ray and a colliding tile.
	 ]]></haxe_doc>
		</ray>
		<autoTile set="method" line="600">
			<f a="Index">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * An internal function used by the binary auto-tilers.
	 * 
	 * @param	Index		The index of the tile you want to analyze.
	 </haxe_doc>
		</autoTile>
		<updateTileGraphic set="method" line="635"><f a="X:Y:Data">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></updateTileGraphic>
		<getAlpha public="1" set="method" line="655">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>alpha</code> to a number between 0 and 1 to change the opacity of the tilemap.
	 ]]></haxe_doc>
		</getAlpha>
		<setAlpha public="1" set="method" line="659"><f a="Alpha">
	<c path="Float"/>
	<c path="Float"/>
</f></setAlpha>
		<new public="1" set="method" line="108">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * The tilemap constructor just initializes some basic variables.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a traditional tilemap display and collision class.
 * It takes a string of comma-separated numbers and then associates
 * those values with tiles from the sheet you pass in.
 * It also includes some handy static parsers that can convert
 * arrays or PNG files into strings that can be successfully loaded.
 </haxe_doc>
	</class>
	<enum path="haxel.Visibility" params="" file="../haxel/HxlTilemap.hx" module="haxel.HxlTilemap">
		<UNSEEN/>
		<SEEN/>
		<IN_SIGHT/>
	</enum>
	<class path="haxel.HxlTile" params="" file="../haxel/HxlTilemap.hx" module="haxel.HxlTilemap">
		<visibility public="1"><e path="haxel.Visibility"/></visibility>
		<isBlockingView public="1" set="method" line="681"><f a=""><e path="Bool"/></f></isBlockingView>
		<isBlockingMovement public="1" set="method" line="682"><f a=""><e path="Bool"/></f></isBlockingMovement>
		<bitmapRect public="1">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>
	 * A Rectangle describing the location of this tiles graphic on the HxlTilemap bitmap.
	 </haxe_doc>
		</bitmapRect>
		<mapX public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The coordinates of this tile within the HxlTilemap.
	 </haxe_doc>
		</mapX>
		<mapY public="1"><c path="Int"/></mapY>
		<dataNum public="1">
			<c path="Int"/>
			<haxe_doc>
	 * An Int representing the index of the graphic to use for this tile. If 0, tile has no graphic.
	 </haxe_doc>
		</dataNum>
		<blend public="1">
			<c path="String"/>
			<haxe_doc>
	 * Blending modes, just like Photoshop!
	 * E.g. "multiply", "screen", etc.
	 * @default null
	 </haxe_doc>
		</blend>
		<_alpha><c path="Float"/></_alpha>
		<_color><c path="Int"/></_color>
		<_ct public="1"><c path="flash.geom.ColorTransform"/></_ct>
		<_mtx><c path="flash.geom.Matrix"/></_mtx>
		<alpha public="1" get="getAlpha" set="setAlpha"><c path="Float"/></alpha>
		<color public="1" get="getColor" set="setColor"><c path="Int"/></color>
		<getAlpha public="1" set="method" line="727">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>alpha</code> to a number between 0 and 1 to change the opacity of this tile.
	 ]]></haxe_doc>
		</getAlpha>
		<setAlpha public="1" set="method" line="731"><f a="Alpha">
	<c path="Float"/>
	<c path="Float"/>
</f></setAlpha>
		<getColor public="1" set="method" line="746">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>color</code> to a number in this format: 0xRRGGBB.
	 * <code>color</code> IGNORES ALPHA.  To change the opacity use <code>alpha</code>.
	 * Tints the whole sprite to be this color (similar to OpenGL vertex colors).
	 ]]></haxe_doc>
		</getColor>
		<setColor public="1" set="method" line="750"><f a="Color">
	<c path="Int"/>
	<c path="Int"/>
</f></setColor>
		<new public="1" set="method" line="714"><f a="?X:?Y:?Rect">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Scene" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.Responder" params="" file="C:\Motion-Twin\haxe/std/flash9/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="Main" params="" file="Main.hx">
		<main public="1" set="method" line="11" static="1"><f a=""><e path="Void"/></f></main>
		<new public="1" set="method" line="22"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="52" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="C:\Motion-Twin\haxe/std/flash9/media/MicrophoneEnhancedOptions.hx" extern="1">
		<autoGain public="1"><e path="Bool"/></autoGain>
		<echoPath public="1"><c path="Int"/></echoPath>
		<isVoiceDetected public="1" set="null"><c path="Int"/></isVoiceDetected>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.Expo" params="" file="../com/eclecticdesignstudio/motion/easing/Expo.hx">
		<easeIn public="1" get="getEaseIn" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeIn>
		<easeInOut public="1" get="getEaseInOut" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeInOut>
		<easeOut public="1" get="getEaseOut" set="null" static="1"><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></easeOut>
		<getEaseIn set="method" line="19" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseIn>
		<getEaseInOut set="method" line="26" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseInOut>
		<getEaseOut set="method" line="33" static="1"><f a=""><c path="com.eclecticdesignstudio.motion.easing.IEasing"/></f></getEaseOut>
		<haxe_doc>
 * @author Joshua Granick
 * @author Robert Penner / http://www.robertpenner.com/easing_terms_of_use.html
 </haxe_doc>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.ExpoEaseIn" params="" file="../com/eclecticdesignstudio/motion/easing/Expo.hx" module="com.eclecticdesignstudio.motion.easing.Expo">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<calculate public="1" set="method" line="53"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="60"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<new public="1" set="method" line="46"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.ExpoEaseInOut" params="" file="../com/eclecticdesignstudio/motion/easing/Expo.hx" module="com.eclecticdesignstudio.motion.easing.Expo">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<calculate public="1" set="method" line="80"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="92"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<new public="1" set="method" line="73"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="com.eclecticdesignstudio.motion.easing.ExpoEaseOut" params="" file="../com/eclecticdesignstudio/motion/easing/Expo.hx" module="com.eclecticdesignstudio.motion.easing.Expo">
		<implements path="com.eclecticdesignstudio.motion.easing.IEasing"/>
		<calculate public="1" set="method" line="121"><f a="k">
	<c path="Float"/>
	<c path="Float"/>
</f></calculate>
		<ease public="1" set="method" line="128"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></ease>
		<new public="1" set="method" line="114"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
	</enum>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="com.eclecticdesignstudio.motion.actuators.MethodActuator" params="" file="../com/eclecticdesignstudio/motion/actuators/MethodActuator.hx">
		<extends path="com.eclecticdesignstudio.motion.actuators.SimpleActuator"/>
		<tweenProperties public="1"><d/></tweenProperties>
		<apply set="method" line="24" override="1"><f a=""><e path="Void"/></f></apply>
		<initialize set="method" line="28" override="1"><f a=""><e path="Void"/></f></initialize>
		<update set="method" line="43" override="1"><f a="currentTime">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<new public="1" set="method" line="11"><f a="target:duration:properties">
	<d/>
	<c path="Float"/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Matrix.hx" extern="1">
		<a public="1"><c path="Float"/></a>
		<b public="1"><c path="Float"/></b>
		<c public="1"><c path="Float"/></c>
		<d public="1"><c path="Float"/></d>
		<tx public="1"><c path="Float"/></tx>
		<ty public="1"><c path="Float"/></ty>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetStreamMulticastInfo.hx" extern="1">
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
	</enum>
	<class path="flash.media.ID3Info" params="" file="C:\Motion-Twin\haxe/std/flash9/media/ID3Info.hx" extern="1">
		<album public="1"><c path="String"/></album>
		<artist public="1"><c path="String"/></artist>
		<comment public="1"><c path="String"/></comment>
		<genre public="1"><c path="String"/></genre>
		<songName public="1"><c path="String"/></songName>
		<track public="1"><c path="String"/></track>
		<year public="1"><c path="String"/></year>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenuClipboardItems.hx" extern="1">
		<clear public="1"><e path="Bool"/></clear>
		<copy public="1"><e path="Bool"/></copy>
		<cut public="1"><e path="Bool"/></cut>
		<paste public="1"><e path="Bool"/></paste>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.media.SoundTransform" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<pan public="1"><c path="Float"/></pan>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<volume public="1"><c path="Float"/></volume>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\haxe/std/flash9/_std/Std.hx">
		<is public="1" set="method" line="28" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="32" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="36" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="40" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="51" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="C:\Motion-Twin\haxe/std/flash9/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
	</enum>
	<class path="flash.events.MouseEvent" params="" file="C:\Motion-Twin\haxe/std/flash9/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<altKey public="1"><e path="Bool"/></altKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<delta public="1"><c path="Int"/></delta>
		<isRelatedObjectInaccessible public="1"><e path="Bool"/></isRelatedObjectInaccessible>
		<localX public="1"><c path="Float"/></localX>
		<localY public="1"><c path="Float"/></localY>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.SharedObject" params="" file="C:\Motion-Twin\haxe/std/flash9/net/SharedObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<deleteAll public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></deleteAll>
		<getDiskUsage public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<c path="Int"/>
</f></getDiskUsage>
		<getLocal public="1" set="method" static="1"><f a="name:?localPath:?secure">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getLocal>
		<getRemote public="1" set="method" static="1"><f a="name:?remotePath:?persistence:?secure">
	<c path="String"/>
	<c path="String"/>
	<d/>
	<e path="Bool"/>
	<c path="flash.net.SharedObject"/>
</f></getRemote>
		<client public="1"><d/></client>
		<data public="1" set="null"><d/></data>
		<fps public="1" get="null"><c path="Float"/></fps>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<size public="1" set="null"><t path="UInt"/></size>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<connect public="1" set="method"><f a="myConnection:?params">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></connect>
		<flush public="1" set="method"><f a="?minDiskSpace">
	<c path="Int"/>
	<e path="flash.net.SharedObjectFlushStatus"/>
</f></flush>
		<send public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<setDirty public="1" set="method"><f a="propertyName">
	<c path="String"/>
	<e path="Void"/>
</f></setDirty>
		<setProperty public="1" set="method"><f a="propertyName:?value">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setProperty>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Rectangle.hx" extern="1">
		<bottom public="1"><c path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><c path="Float"/></height>
		<left public="1"><c path="Float"/></left>
		<right public="1"><c path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><c path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="C:\Motion-Twin\haxe/std/flash9/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
	</enum>
	<class path="haxel.HxlSave" params="" file="../haxel/HxlSave.hx">
		<data public="1">
			<d/>
			<haxe_doc>
	 * Allows you to directly access the data container in the local shared object.
	 * @default null
	 </haxe_doc>
		</data>
		<name public="1">
			<c path="String"/>
			<haxe_doc>
	 * The name of the local shared object.
	 * @default null
	 </haxe_doc>
		</name>
		<_so>
			<c path="flash.net.SharedObject"/>
			<haxe_doc>
	 * The local shared object itself.
	 * @default null
	 </haxe_doc>
		</_so>
		<bind public="1" set="method" line="50">
			<f a="Name">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Automatically creates or reconnects to locally saved data.
	 * 
	 * @param	Name	The name of the object (should be the same each time to access old data).
	 * 
	 * @return	Whether or not you successfully connected to the save data.
	 </haxe_doc>
		</bind>
		<write public="1" set="method" line="81">
			<f a="FieldName:FieldValue:?MinFileSize">
				<c path="String"/>
				<d/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * If you don't like to access the data object directly, you can use this to write to it.
	 * 
	 * @param	FieldName		The name of the data field you want to create or overwrite.
	 * @param	FieldValue		The data you want to store.
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * 
	 * @return	Whether or not the write and flush were successful.
	 </haxe_doc>
		</write>
		<read public="1" set="method" line="97">
			<f a="FieldName">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
	 * If you don't like to access the data object directly, you can use this to read from it.
	 * 
	 * @param	FieldName		The name of the data field you want to read
	 * 
	 * @return	The value of the data field you are reading (null if it doesn't exist).
	 </haxe_doc>
		</read>
		<forceSave public="1" set="method" line="112">
			<f a="?MinFileSize">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Writes the local shared object to disk immediately.
	 *
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 *
	 * @return	Whether or not the flush was successful.
	 </haxe_doc>
		</forceSave>
		<erase public="1" set="method" line="142">
			<f a="?MinFileSize">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * Erases everything stored in the local shared object.
	 * 
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * 
	 * @return	Whether or not the clear and flush was successful.
	 </haxe_doc>
		</erase>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Blanks out the containers.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A class to help automate and simplify save game functionality.
 </haxe_doc>
	</class>
	<class path="haxel.HxlMouse" params="" file="../haxel/HxlMouse.hx">
		<ImgDefaultCursor><c path="Class"><c path="flash.display.Bitmap"/></c></ImgDefaultCursor>
		<x public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Current X position of the mouse pointer in the game world.
	 </haxe_doc>
		</x>
		<y public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Current Y position of the mouse pointer in the game world.
	 </haxe_doc>
		</y>
		<screenX public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Current X position of the mouse pointer on the screen.
	 </haxe_doc>
		</screenX>
		<screenY public="1">
			<c path="Int"/>
			<haxe_doc>
	 * Current Y position of the mouse pointer on the screen.
	 </haxe_doc>
		</screenY>
		<cursor public="1">
			<c path="haxel.HxlSprite"/>
			<haxe_doc>
	 * Graphical representation of the mouse pointer.
	 </haxe_doc>
		</cursor>
		<_current>
			<c path="Int"/>
			<haxe_doc>
	 * Helper variable for tracking whether the mouse was just pressed or just released.
	 </haxe_doc>
		</_current>
		<_last>
			<c path="Int"/>
			<haxe_doc>
	 * Helper variable for tracking whether the mouse was just pressed or just released.
	 </haxe_doc>
		</_last>
		<_out>
			<e path="Bool"/>
			<haxe_doc>
	 * Helper for mouse visibility.
	 </haxe_doc>
		</_out>
		<show public="1" set="method" line="68">
			<f a="?Graphic:?XOffset:?YOffset">
				<c path="Class"><c path="flash.display.Bitmap"/></c>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Either show an existing cursor or load a new one.
	 * 
	 * @param	Graphic		The image you want to use for the cursor.
	 * @param	XOffset		The number of pixels between the mouse's screen position and the graphic's top left corner.
	 * * @param	YOffset		The number of pixels between the mouse's screen position and the graphic's top left corner. 
	 </haxe_doc>
		</show>
		<hide public="1" set="method" line="82">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Hides the mouse cursor
	 </haxe_doc>
		</hide>
		<load public="1" set="method" line="96">
			<f a="Graphic:?XOffset:?YOffset">
				<c path="Class"><c path="flash.display.Bitmap"/></c>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Load a new mouse cursor graphic
	 * 
	 * @param	Graphic		The image you want to use for the cursor.
	 * @param	XOffset		The number of pixels between the mouse's screen position and the graphic's top left corner.
	 * * @param	YOffset		The number of pixels between the mouse's screen position and the graphic's top left corner. 
	 </haxe_doc>
		</load>
		<unload public="1" set="method" line="109">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Unload the current cursor graphic.  If the current cursor is visible,
	 * then the default system cursor is loaded up to replace the old one.
	 </haxe_doc>
		</unload>
		<update public="1" set="method" line="128">
			<f a="X:Y:XScroll:YScroll">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Called by the internal game loop to update the mouse pointer's position in the game world.
	 * Also updates the just pressed/just released flags.
	 * 
	 * @param	X			The current X position of the mouse in the window.
	 * @param	Y			The current Y position of the mouse in the window.
	 * @param	XScroll		The amount the game world has scrolled horizontally.
	 * @param	YScroll		The amount the game world has scrolled vertically.
	 </haxe_doc>
		</update>
		<reset public="1" set="method" line="148">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resets the just pressed/just released flags and sets mouse to not pressed.
	 </haxe_doc>
		</reset>
		<pressed public="1" set="method" line="158">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Check to see if the mouse is pressed.
	 * 
	 * @return	Whether the mouse is pressed.
	 </haxe_doc>
		</pressed>
		<justPressed public="1" set="method" line="165">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Check to see if the mouse was just pressed.
	 * 
	 * @return Whether the mouse was just pressed.
	 </haxe_doc>
		</justPressed>
		<justReleased public="1" set="method" line="172">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
	 * Check to see if the mouse was just released.
	 * 
	 * @return	Whether the mouse was just released.
	 </haxe_doc>
		</justReleased>
		<handleMouseDown public="1" set="method" line="179">
			<f a="event">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Event handler so FlxGame can toggle the mouse.
	 * 
	 * @param	event	A <code>MouseEvent</code> object.
	 ]]></haxe_doc>
		</handleMouseDown>
		<handleMouseUp public="1" set="method" line="192">
			<f a="event">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Event handler so FlxGame can toggle the mouse.
	 * 
	 * @param	event	A <code>MouseEvent</code> object.
	 ]]></haxe_doc>
		</handleMouseUp>
		<handleMouseOut public="1" set="method" line="205">
			<f a="event">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Event handler so FlxGame can toggle the mouse.
	 * 
	 * @param	event	A <code>MouseEvent</code> object.
	 ]]></haxe_doc>
		</handleMouseOut>
		<handleMouseOver public="1" set="method" line="217">
			<f a="event">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Event handler so FlxGame can toggle the mouse.
	 * 
	 * @param	event	A <code>MouseEvent</code> object.
	 ]]></haxe_doc>
		</handleMouseOver>
		<new public="1" set="method" line="50">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
	</class>
	<enum path="flash.utils.Endian" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundLoaderContext.hx" extern="1">
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>
	The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.
</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<enum path="flash.events.EventPhase" params="" file="C:\Motion-Twin\haxe/std/flash9/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
	</enum>
	<class path="flash.display.Bitmap" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.system.IMEConversionMode" params="" file="C:\Motion-Twin\haxe/std/flash9/system/IMEConversionMode.hx">
		<UNKNOWN/>
		<KOREAN/>
		<JAPANESE_KATAKANA_HALF/>
		<JAPANESE_KATAKANA_FULL/>
		<JAPANESE_HIRAGANA/>
		<CHINESE/>
		<ALPHANUMERIC_HALF/>
		<ALPHANUMERIC_FULL/>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
	</enum>
	<class path="flash.net.NetConnection" params="" file="C:\Motion-Twin\haxe/std/flash9/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<client public="1"><d/></client>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<farID public="1" set="null"><c path="String"/></farID>
		<farNonce public="1" set="null"><c path="String"/></farNonce>
		<maxPeerConnections public="1"><t path="UInt"/></maxPeerConnections>
		<nearID public="1" set="null"><c path="String"/></nearID>
		<nearNonce public="1" set="null"><c path="String"/></nearNonce>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<protocol public="1" set="null"><c path="String"/></protocol>
		<proxyType public="1"><c path="String"/></proxyType>
		<unconnectedPeerStreams public="1" set="null"><c path="Array"><d/></c></unconnectedPeerStreams>
		<uri public="1" set="null"><c path="String"/></uri>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.IDataInput" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="flash.display.MouseCursorData" params="" file="C:\Motion-Twin\haxe/std/flash9/display/MouseCursorData.hx" extern="1">
		<data public="1"><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></data>
		<frameRate public="1"><c path="Float"/></frameRate>
		<hotSpot public="1"><c path="flash.geom.Point"/></hotSpot>
		<name public="1"><c path="String"/></name>
		<new public="1"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.xml.XML" params="" file="C:\Motion-Twin\haxe/std/flash9/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<name public="1" set="method"><f a=""><d/></f></name>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.geom.Vector3D" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<length public="1" set="null"><c path="Float"/></length>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<w public="1"><c path="Float"/></w>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<z public="1"><c path="Float"/></z>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.IME" params="" file="C:\Motion-Twin\haxe/std/flash9/system/IME.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<constructOK public="1" get="null" static="1"><e path="Bool"/></constructOK>
		<conversionMode public="1" static="1"><e path="flash.system.IMEConversionMode"/></conversionMode>
		<enabled public="1" static="1"><e path="Bool"/></enabled>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<compositionAbandoned public="1" static="1"><f a=""><e path="Void"/></f></compositionAbandoned>
		<compositionSelectionChanged public="1" static="1"><f a="start:end">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></compositionSelectionChanged>
		<doConversion public="1" set="method" static="1"><f a=""><e path="Void"/></f></doConversion>
		<setCompositionString public="1" set="method" static="1"><f a="composition">
	<c path="String"/>
	<e path="Void"/>
</f></setCompositionString>
	</class>
	<class path="flash.net.URLRequest" params="" file="C:\Motion-Twin\haxe/std/flash9/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1"><c path="String"/></digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextField" params="" file="C:\Motion-Twin\haxe/std/flash9/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1"><f a="fontName:fontStyle">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></isFontCompatible>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><e path="Bool"/></background>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<border public="1"><e path="Bool"/></border>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><c path="Int"/></length>
		<maxChars public="1"><c path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><e path="Bool"/></multiline>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><c path="Int"/></scrollH>
		<scrollV public="1"><c path="Int"/></scrollV>
		<selectable public="1"><e path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<sharpness public="1"><c path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><t path="UInt"/></textColor>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<thickness public="1"><c path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.Vector" params="T" file="C:\Motion-Twin\haxe/std/flash9/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<length public="1"><t path="UInt"/></length>
		<fixed public="1"><e path="Bool"/></fixed>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Vector class is very similar to Array but is only supported by the Flash Player 10+
</haxe_doc>
	</class>
	<enum path="flash.display.StageScaleMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
	</enum>
	<class path="com.eclecticdesignstudio.motion.actuators.PropertyDetails" params="" file="../com/eclecticdesignstudio/motion/actuators/PropertyDetails.hx">
		<target public="1"><d/></target>
		<propertyName public="1"><c path="String"/></propertyName>
		<start public="1"><c path="Float"/></start>
		<change public="1"><c path="Float"/></change>
		<new public="1" set="method" line="18"><f a="target:propertyName:start:change">
	<d/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * @author Joshua Granick
 </haxe_doc>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="C:\Motion-Twin\haxe/std/flash9/media/SoundCodec.hx">
		<SPEEX/>
		<NELLYMOSER/>
	</enum>
	<class path="haxel.HxlQuadTree" params="" file="../haxel/HxlQuadTree.hx">
		<extends path="haxel.HxlRect"/>
		<A_LIST public="1" line="17" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Flag for specifying that you want to add an object to the A list.
	 </haxe_doc>
		</A_LIST>
		<B_LIST public="1" line="21" static="1">
			<c path="Int"/>
			<haxe_doc>
	 * Flag for specifying that you want to add an object to the B list.
	 </haxe_doc>
		</B_LIST>
		<_min static="1">
			<c path="Int"/>
			<haxe_doc>
	 * These variables refer to the potential child quadrants for this node.
	 </haxe_doc>
		</_min>
		<_o static="1">
			<c path="haxel.HxlObject"/>
			<haxe_doc>
	 * These objects are used to reduce recursive parameters internally.
	 </haxe_doc>
		</_o>
		<_ol static="1"><c path="Float"/></_ol>
		<_ot static="1"><c path="Float"/></_ot>
		<_or static="1"><c path="Float"/></_or>
		<_ob static="1"><c path="Float"/></_ob>
		<_oa static="1"><c path="Int"/></_oa>
		<_oc static="1"><d/></_oc>
		<_canSubdivide>
			<e path="Bool"/>
			<haxe_doc>
	 * Whether this branch of the tree can be subdivided or not.
	 </haxe_doc>
		</_canSubdivide>
		<_headA>
			<c path="haxel.HxlList"/>
			<haxe_doc>
	 * These variables refer to the internal A and B linked lists,
	 * which are used to store objects in the leaves.
	 </haxe_doc>
		</_headA>
		<_tailA><c path="haxel.HxlList"/></_tailA>
		<_headB><c path="haxel.HxlList"/></_headB>
		<_tailB><c path="haxel.HxlList"/></_tailB>
		<_nw><c path="haxel.HxlQuadTree"/></_nw>
		<_ne><c path="haxel.HxlQuadTree"/></_ne>
		<_se><c path="haxel.HxlQuadTree"/></_se>
		<_sw><c path="haxel.HxlQuadTree"/></_sw>
		<_l><c path="Float"/></_l>
		<_r><c path="Float"/></_r>
		<_t><c path="Float"/></_t>
		<_b><c path="Float"/></_b>
		<_hw><c path="Float"/></_hw>
		<_hh><c path="Float"/></_hh>
		<_mx><c path="Float"/></_mx>
		<_my><c path="Float"/></_my>
		<add public="1" set="method" line="139">
			<f a="Object:List">
				<c path="haxel.HxlObject"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Call this function to add an object to the root of the tree.
	 * This function will recursively add all group members, but
	 * not the groups themselves.
	 * 
	 * @param	Object		The <code>HxlObject</code> you want to add.  <code>HxlGroup</code> objects will be recursed and their applicable members added automatically.
	 * @param	List		A <code>Int</code> flag indicating the list to which you want to add the objects.  Options are <code>A_LIST</code> and <code>B_LIST</code>.
	 ]]></haxe_doc>
		</add>
		<addObject set="method" line="175">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function for recursively navigating and creating the tree
	 * while adding objects to the appropriate nodes.
	 </haxe_doc>
		</addObject>
		<addToList set="method" line="246">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function for recursively adding objects to leaf lists.
	 </haxe_doc>
		</addToList>
		<overlap public="1" set="method" line="289">
			<f a="?BothLists:?Callback">
				<e path="Bool"/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc><![CDATA[
	 * <code>HxlQuadTree</code>'s other main function.  Call this after adding objects
	 * using <code>HxlQuadTree.add()</code> to compare the objects that you loaded.
	 * 
	 * @param	BothLists	Whether you are doing an A-B list comparison, or comparing A against itself.
	 * @param	Callback	A function with two <code>HxlObject</code> parameters - e.g. <code>myOverlapFunction(Object1:HxlObject,Object2:HxlObject);</code>  If no function is provided, <code>HxlQuadTree</code> will call <code>kill()</code> on both objects.
	 *
	 * @return	Whether or not any overlaps were found.
	 ]]></haxe_doc>
		</overlap>
		<overlapNode set="method" line="366">
			<f a="?Iterator">
				<c path="haxel.HxlList"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	 * An internal function for comparing an object against the contents of a node.
	 * 
	 * @param	Iterator	An optional pointer to a linked list entry (for comparing A against itself).
	 * 
	 * @return	Whether or not any overlaps were found.
	 </haxe_doc>
		</overlapNode>
		<new public="1" set="method" line="74">
			<f a="X:Y:Width:Height:?Parent">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="haxel.HxlQuadTree"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Instantiate a new Quad Tree node.
	 * 
	 * @param	X			The X-coordinate of the point in space.
	 * @param	Y			The Y-coordinate of the point in space.
	 * @param	Width		Desired width of this node.
	 * @param	Height		Desired height of this node.
	 * @param	Parent		The parent branch or node.  Pass null to create a root.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A fairly generic quad tree structure for rapid overlap checks.
 * HxlQuadTree is also configured for single or dual list operation.
 * You can add items either to its A list or its B list.
 * When you do an overlap check, you can compare the A list to itself,
 * or the A list against the B list.  Handy for different things!
 </haxe_doc>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="C:\Motion-Twin\haxe/std/flash9/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="C:\Motion-Twin\haxe/std/flash9/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
	</enum>
	<class path="haxel.HxlMenuItem" params="" file="../haxel/HxlMenuItem.hx">
		<extends path="haxel.HxlText"/>
		<normalFormat><c path="flash.text.TextFormat"/></normalFormat>
		<hoverFormat><c path="flash.text.TextFormat"/></hoverFormat>
		<showHover><e path="Bool"/></showHover>
		<itemCallback public="1" get="getCallback" set="setCallback"><d/></itemCallback>
		<_itemCallback><d/></_itemCallback>
		<setHover public="1" set="method" line="29"><f a="?Hover">
	<e path="Bool"/>
	<e path="Void"/>
</f></setHover>
		<setNormalFormat public="1" set="method" line="40"><f a="?Font:?Size:?Color:?Alignment:?ShadowColor">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setNormalFormat>
		<setHoverFormat public="1" set="method" line="49"><f a="?Font:?Size:?Color:?Alignment:?ShadowColor">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setHoverFormat>
		<getCallback public="1" set="method" line="58"><f a=""><d/></f></getCallback>
		<setCallback public="1" set="method" line="62"><f a="ItemCallback">
	<d/>
	<d/>
</f></setCallback>
		<new public="1" set="method" line="22"><f a="X:Y:Width:?Text:?EmbeddedFont:?FontName">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="C:\Motion-Twin\haxe/std/flash9/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
	</enum>
	<class path="flash.utils.ByteArray" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><t path="UInt"/></length>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<position public="1"><t path="UInt"/></position>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<deflate public="1" set="method"><f a=""><e path="Void"/></f></deflate>
		<inflate public="1" set="method"><f a=""><e path="Void"/></f></inflate>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\Motion-Twin\haxe/std/flash9/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1"><e path="Bool"/></isSupported>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<clipboardItems public="1"><c path="flash.ui.ContextMenuClipboardItems"/></clipboardItems>
		<clipboardMenu public="1"><e path="Bool"/></clipboardMenu>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<link public="1"><c path="flash.net.URLRequest"/></link>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Loader" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<uncaughtErrorEvents public="1"><c path="flash.events.UncaughtErrorEvents"/></uncaughtErrorEvents>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<unloadAndStop public="1" set="method"><f a="?gc">
	<e path="Bool"/>
	<e path="Void"/>
</f></unloadAndStop>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.Timer" params="" file="C:\Motion-Twin\haxe/std/flash9/utils/Timer.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<currentCount public="1" set="null"><c path="Int"/></currentCount>
		<delay public="1"><c path="Float"/></delay>
		<repeatCount public="1"><c path="Int"/></repeatCount>
		<running public="1" set="null"><e path="Bool"/></running>
		<reset public="1" set="method"><f a=""><e path="Void"/></f></reset>
		<start public="1" set="method"><f a=""><e path="Void"/></f></start>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<new public="1" set="method"><f a="delay:?repeatCount">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Sound" params="" file="C:\Motion-Twin\haxe/std/flash9/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<isURLInaccessible public="1"><e path="Bool"/></isURLInaccessible>
		<length public="1" set="null"><c path="Float"/></length>
		<url public="1" set="null"><c path="String"/></url>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<extract public="1" set="method"><f a="target:length:?startPosition">
	<c path="flash.utils.ByteArray"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></extract>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.StageQuality" params="" file="C:\Motion-Twin\haxe/std/flash9/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH/>
		<BEST/>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="C:\Motion-Twin\haxe/std/flash9/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
	</enum>
	<enum path="flash.text.FontStyle" params="" file="C:\Motion-Twin\haxe/std/flash9/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
	</enum>
	<class path="haxel.HxlSound" params="" file="../haxel/HxlSound.hx">
		<extends path="haxel.HxlObject"/>
		<volume public="1" get="getVolume" set="setVolume"><c path="Float"/></volume>
		<survive public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether or not this sound should be automatically destroyed when you switch states.
	 </haxe_doc>
		</survive>
		<playing public="1">
			<e path="Bool"/>
			<haxe_doc>
	 * Whether the sound is currently playing or not.
	 </haxe_doc>
		</playing>
		<name public="1">
			<c path="String"/>
			<haxe_doc>
	 * The ID3 song name.  Defaults to null.  Currently only works for streamed sounds.
	 </haxe_doc>
		</name>
		<artist public="1">
			<c path="String"/>
			<haxe_doc>
	 * The ID3 artist name.  Defaults to null.  Currently only works for streamed sounds.
	 </haxe_doc>
		</artist>
		<_init><e path="Bool"/></_init>
		<_sound><c path="flash.media.Sound"/></_sound>
		<_channel><c path="flash.media.SoundChannel"/></_channel>
		<_transform><c path="flash.media.SoundTransform"/></_transform>
		<_position><c path="Float"/></_position>
		<_volume><c path="Float"/></_volume>
		<_volumeAdjust><c path="Float"/></_volumeAdjust>
		<_looped><e path="Bool"/></_looped>
		<_core><c path="haxel.HxlObject"/></_core>
		<_radius><c path="Float"/></_radius>
		<_pan><e path="Bool"/></_pan>
		<_fadeOutTimer><c path="Float"/></_fadeOutTimer>
		<_fadeOutTotal><c path="Float"/></_fadeOutTotal>
		<_pauseOnFadeOut><e path="Bool"/></_pauseOnFadeOut>
		<_fadeInTimer><c path="Float"/></_fadeInTimer>
		<_fadeInTotal><c path="Float"/></_fadeInTotal>
		<_point2><c path="haxel.HxlPoint"/></_point2>
		<init set="method" line="61">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * An internal function for clearing all the variables used by sounds.
	 </haxe_doc>
		</init>
		<loadEmbedded public="1" set="method" line="93">
			<f a="EmbeddedSound:?Looped">
				<c path="Class"><c path="flash.media.Sound"/></c>
				<e path="Bool"/>
				<c path="haxel.HxlSound"/>
			</f>
			<haxe_doc><![CDATA[
	 * One of two main setup functions for sounds, this function loads a sound from an embedded MP3.
	 * 
	 * @param	EmbeddedSound	An embedded Class object representing an MP3 file.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * 
	 * @return	This <code>FlxSound</code> instance (nice for chaining stuff together, if you're into that).
	 ]]></haxe_doc>
		</loadEmbedded>
		<loadStream public="1" set="method" line="112">
			<f a="SoundURL:?Looped">
				<c path="String"/>
				<e path="Bool"/>
				<c path="haxel.HxlSound"/>
			</f>
			<haxe_doc><![CDATA[
	 * One of two main setup functions for sounds, this function loads a sound from a URL.
	 * 
	 * @param	EmbeddedSound	A string representing the URL of the MP3 file you want to play.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * 
	 * @return	This <code>FlxSound</code> instance (nice for chaining stuff together, if you're into that).
	 ]]></haxe_doc>
		</loadStream>
		<proximity public="1" set="method" line="135">
			<f a="X:Y:Core:Radius:?Pan">
				<c path="Float"/>
				<c path="Float"/>
				<c path="haxel.HxlObject"/>
				<c path="Float"/>
				<e path="Bool"/>
				<c path="haxel.HxlSound"/>
			</f>
			<haxe_doc>
	 * Call this function if you want this sound's volume to change
	 * based on distance from a particular HxlCore object.
	 * 
	 * @param	X		The X position of the sound.
	 * @param	Y		The Y position of the sound.
	 * @param	Core	The object you want to track.
	 * @param	Radius	The maximum distance this sound can travel.
	 * 
	 * @return	This HxlSound instance (nice for chaining stuff together, if you're into that).
	 </haxe_doc>
		</proximity>
		<play public="1" set="method" line="147">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Call this function to play the sound.
	 </haxe_doc>
		</play>
		<pause public="1" set="method" line="195">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Call this function to pause this sound.
	 </haxe_doc>
		</pause>
		<stop public="1" set="method" line="214">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Call this function to stop this sound.
	 </haxe_doc>
		</stop>
		<fadeOut public="1" set="method" line="228">
			<f a="Seconds:?PauseInstead">
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Call this function to make this sound fade out over a certain time interval.
	 * 
	 * @param	Seconds			The amount of time the fade out operation should take.
	 * @param	PauseInstead	Tells the sound to pause on fadeout, instead of stopping.
	 </haxe_doc>
		</fadeOut>
		<fadeIn public="1" set="method" line="241">
			<f a="Seconds">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Call this function to make a sound fade in over a certain
	 * time interval (calls <code>play()</code> automatically).
	 * 
	 * @param	Seconds		The amount of time the fade-in operation should take.
	 ]]></haxe_doc>
		</fadeIn>
		<getVolume public="1" set="method" line="251">
			<f a=""><c path="Float"/></f>
			<haxe_doc><![CDATA[
	 * Set <code>volume</code> to a value between 0 and 1 to change how this sound is.
	 ]]></haxe_doc>
		</getVolume>
		<setVolume public="1" set="method" line="258">
			<f a="Volume">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
	 * @private
	 </haxe_doc>
		</setVolume>
		<updateSound set="method" line="273">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Internal function that performs the actual logical updates to the sound object.
	 * Doesn't do much except optional proximity and fade calculations.
	 </haxe_doc>
		</updateSound>
		<update public="1" set="method" line="330" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * The basic game loop update function.  Just calls <code>updateSound()</code>.
	 ]]></haxe_doc>
		</update>
		<destroy public="1" set="method" line="338" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * The basic class destructor, stops the music and removes any leftover events.
	 </haxe_doc>
		</destroy>
		<updateTransform public="1" set="method" line="345">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * An internal function used to help organize and change the volume of the sound.
	 </haxe_doc>
		</updateTransform>
		<looped set="method" line="357">
			<f a="?event">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * An internal helper function used to help Flash resume playing a looped sound.
	 * 
	 * @param	event		An <code>Event</code> object.
	 ]]></haxe_doc>
		</looped>
		<stopped set="method" line="371">
			<f a="?event">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * An internal helper function used to help Flash clean up and re-use finished sounds.
	 * 
	 * @param	event		An <code>Event</code> object.
	 ]]></haxe_doc>
		</stopped>
		<gotID3 set="method" line="387">
			<f a="?event">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Internal event handler for ID3 info (i.e. fetching the song name).
	 * 
	 * @param	event	An <code>Event</code> object.
	 ]]></haxe_doc>
		</gotID3>
		<new public="1" set="method" line="50">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * The HxlSound constructor gets all the variables initialized, but NOT ready to play a sound yet.
	 </haxe_doc>
		</new>
	</class>
	<class path="haxel.HxlQuake" params="" file="../haxel/HxlQuake.hx">
		<_zoom>
			<c path="Int"/>
			<haxe_doc>
	 * The game's level of zoom.
	 </haxe_doc>
		</_zoom>
		<_intensity>
			<c path="Float"/>
			<haxe_doc>
	 * The intensity of the quake effect: a percentage of the screen's size.
	 </haxe_doc>
		</_intensity>
		<_timer>
			<c path="Float"/>
			<haxe_doc>
	 * Set to countdown the quake time.
	 </haxe_doc>
		</_timer>
		<x public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The amount of X distortion to apply to the screen.
	 </haxe_doc>
		</x>
		<y public="1">
			<c path="Int"/>
			<haxe_doc>
	 * The amount of Y distortion to apply to the screen.
	 </haxe_doc>
		</y>
		<start public="1" set="method" line="46">
			<f a="?Intensity:?Duration">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Reset and trigger this special effect.
	 * 
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move during the 'quake'.
	 * @param	Duration	The length in seconds that the "quake" should last.
	 </haxe_doc>
		</start>
		<stop public="1" set="method" line="55">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Stops this screen effect.
	 </haxe_doc>
		</stop>
		<update public="1" set="method" line="65">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Updates and/or animates this special effect.
	 </haxe_doc>
		</update>
		<new public="1" set="method" line="35">
			<f a="Zoom">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Constructor.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * This is a special effects utility class to help HxlGame do the 'quake' or screenshake effect.
 </haxe_doc>
	</class>
	<class path="flash.display.Shader" params="" file="C:\Motion-Twin\haxe/std/flash9/display/Shader.hx" extern="1">
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\Motion-Twin\haxe/std/flash9/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<color public="1"><t path="UInt"/></color>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<redOffset public="1"><c path="Float"/></redOffset>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
</haxe>